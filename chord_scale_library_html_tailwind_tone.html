<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chord & Scale Library</title>
  <!-- Tailwind (CDN) for the same look/feel as your TSX version -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <style>
    /* Theme System */
    [data-theme="default"] {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-accent: #334155;
      --text-primary: #f1f5f9;
      --text-secondary: #cbd5e1;
      --text-muted: #64748b;
      --border-color: #475569;
      --accent-color: #3b82f6;
      --success-color: #10b981;
      --warning-color: #f59e0b;
      --danger-color: #ef4444;
      --gradient: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
    }
    
    [data-theme="cyberpunk"] {
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a0a1a;
      --bg-accent: #2a1a2a;
      --text-primary: #ff00ff;
      --text-secondary: #00ffff;
      --text-muted: #666;
      --border-color: #ff00ff;
      --accent-color: #00ffff;
      --success-color: #00ff00;
      --warning-color: #ffff00;
      --danger-color: #ff0080;
      --gradient: linear-gradient(135deg, #000 0%, #1a0a1a 25%, #0a1a0a 50%, #1a0a1a 75%, #000 100%);
    }
    
    [data-theme="forest"] {
      --bg-primary: #0f1b0f;
      --bg-secondary: #1a2e1a;
      --bg-accent: #2d4a2d;
      --text-primary: #d4f4dd;
      --text-secondary: #a7d4aa;
      --text-muted: #6b8e6b;
      --border-color: #4a6741;
      --accent-color: #22c55e;
      --success-color: #16a34a;
      --warning-color: #eab308;
      --danger-color: #dc2626;
      --gradient: linear-gradient(135deg, #0f1b0f 0%, #1a2e1a 50%, #0f1b0f 100%);
    }
    
    [data-theme="ocean"] {
      --bg-primary: #0c1445;
      --bg-secondary: #1e3a8a;
      --bg-accent: #3b82f6;
      --text-primary: #dbeafe;
      --text-secondary: #93c5fd;
      --text-muted: #60a5fa;
      --border-color: #2563eb;
      --accent-color: #0ea5e9;
      --success-color: #06b6d4;
      --warning-color: #0891b2;
      --danger-color: #be123c;
      --gradient: linear-gradient(135deg, #0c1445 0%, #1e3a8a 50%, #0c1445 100%);
    }
    
    [data-theme="sunset"] {
      --bg-primary: #451a03;
      --bg-secondary: #7c2d12;
      --bg-accent: #ea580c;
      --text-primary: #fed7aa;
      --text-secondary: #fdba74;
      --text-muted: #f97316;
      --border-color: #c2410c;
      --accent-color: #f97316;
      --success-color: #eab308;
      --warning-color: #f59e0b;
      --danger-color: #dc2626;
      --gradient: linear-gradient(135deg, #451a03 0%, #7c2d12 25%, #ea580c 50%, #7c2d12 75%, #451a03 100%);
    }
    
    [data-theme="minimal"] {
      --bg-primary: #ffffff;
      --bg-secondary: #f8fafc;
      --bg-accent: #e2e8f0;
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #94a3b8;
      --border-color: #cbd5e1;
      --accent-color: #3b82f6;
      --success-color: #10b981;
      --warning-color: #f59e0b;
      --danger-color: #ef4444;
      --gradient: linear-gradient(135deg, #ffffff 0%, #f8fafc 50%, #ffffff 100%);
    }
    
    /* Apply theme variables */
    [data-theme] {
      background: var(--gradient);
      color: var(--text-primary);
    }
    
    /* Shortcuts modal */
    .shortcuts-modal {
      backdrop-filter: blur(8px);
    }
  </style>
  <!-- Tone.js for audio playback -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
</head>
<body id="app-container" class="min-h-screen w-full bg-slate-950 text-slate-100" data-theme="default">
  <div class="max-w-6xl mx-auto p-6">
    <header class="mb-6 flex items-center justify-between">
      <h1 class="text-2xl md:text-3xl font-bold">Chord & Scale Library</h1>
      <div class="flex items-center gap-4">
        <button id="shortcutsBtn" class="px-3 py-2 rounded-lg bg-slate-800/60 hover:bg-slate-700/60 border border-slate-700 text-sm font-medium transition-colors" title="Show keyboard shortcuts">
          ‚å®Ô∏è Shortcuts
        </button>
        <select id="themeSwitcher" class="bg-slate-800/80 border border-slate-700 rounded-lg px-3 py-2 text-sm font-medium cursor-pointer hover:bg-slate-700/80 transition-colors">
          <option value="default">üåô Default</option>
          <option value="cyberpunk">üåà Cyberpunk</option>
          <option value="forest">üå≤ Forest</option>
          <option value="ocean">üåä Ocean</option>
          <option value="sunset">üåÖ Sunset</option>
          <option value="minimal">‚ö™ Minimal</option>
        </select>
        <div class="text-xs text-slate-400">Audio starts on first click ‚Ä¢ Tone.js</div>
      </div>
    </header>

    <!-- ============ 1) Choose What To Explore ============ -->
    <section class="mb-6">
      <h2 class="text-lg font-semibold text-slate-100 mb-2">1) Choose What To Explore</h2>
      <div class="bg-slate-800/60 rounded-2xl p-4 border border-slate-700">
        <div class="flex flex-wrap gap-3 items-center">
          <div class="inline-flex rounded-xl overflow-hidden border border-slate-700">
            <button id="btnModeChord" class="px-3 py-2 text-sm bg-slate-700/70">Chord</button>
            <button id="btnModeScale" class="px-3 py-2 text-sm bg-slate-800/60 hover:bg-slate-700/50">Scale/Mode</button>
            <button id="btnModeSequencer" class="px-3 py-2 text-sm bg-slate-800/60 hover:bg-slate-700/50">Sequencer</button>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-slate-300">System</label>
            <select id="selSystem" class="bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1"></select>
          </div>

          <div class="flex items-center gap-2">
            <label class="text-sm text-slate-300">Key / Root</label>
            <select id="selKey" class="bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1"></select>
            <span id="badgeRoot" class="px-2 py-0.5 rounded-full text-xs font-semibold border bg-emerald-600/20 text-emerald-300 border-emerald-600/40"></span>
          </div>

          <div id="wrapChord" class="flex items-center gap-2">
            <label class="text-sm text-slate-300">Quality</label>
            <select id="selQuality" class="bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1"></select>
            <span id="badgeChordNotes" class="px-2 py-0.5 rounded-full text-xs font-semibold border bg-slate-700/40 text-slate-300 border-slate-600"></span>
          </div>

          <div id="wrapScale" class="hidden items-center gap-2">
            <label class="text-sm text-slate-300">Mode</label>
            <select id="selMode" class="bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1"></select>
            <span id="badgeScaleNotes" class="px-2 py-0.5 rounded-full text-xs font-semibold border bg-slate-700/40 text-slate-300 border-slate-600"></span>
          </div>

          <div class="flex items-center gap-2 ml-auto">
            <label class="text-sm text-slate-300">Instrument</label>
            <select id="selInstr" class="bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1"></select>
            <label class="text-sm text-slate-300">Tempo</label>
            <input id="tempo" type="number" class="w-20 bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1" value="120" />
          </div>
          
        </div>
      </div>
    </section>

    <!-- ============ 2) Visualize On Your Instrument ============ -->
    <section class="mb-6">
      <h2 class="text-lg font-semibold text-slate-100 mb-2">2) Visualize On Your Instrument</h2>
      <div class="bg-slate-800/60 rounded-2xl p-4 border border-slate-700 space-y-6">
        <div id="pianoHost"></div>
        <div id="guitarHost" class="hidden"></div>
        <div id="bassHost" class="hidden"></div>
        <div id="violinHost" class="hidden"></div>
        <div id="fluteHost" class="hidden"></div>
        <div id="recorderHost" class="hidden"></div>
        <div id="trumpetHost" class="hidden"></div>
        <div id="saxophoneHost" class="hidden"></div>
        <div id="kotoHost" class="hidden"></div>
        <div id="neyHost" class="hidden"></div>

        <div class="flex items-center gap-2 pt-1">
          <span id="badgeId" class="px-2 py-0.5 rounded-full text-xs font-semibold border bg-slate-700/40 text-slate-300 border-slate-600">Selection: ‚Äî</span>
          <span id="badgeSelNotes" class="px-2 py-0.5 rounded-full text-xs font-semibold border bg-slate-700/40 text-slate-300 border-slate-600">Notes: ‚Äî</span>
          <button id="btnClearSel" class="px-2 py-1 text-xs font-semibold rounded-lg border bg-slate-700/40 text-slate-300 border-slate-600 hover:bg-slate-700/60">Clear Selection</button>
          <span class="text-xs text-slate-400">Tip: hold keys to play ‚Ä¢ <span class="font-semibold">Shift+click</span> toggles selection</span>
        </div>
      </div>
    </section>

    <!-- ============ 3) Listen ============ -->
    <section class="mb-6">
      <h2 class="text-lg font-semibold text-slate-100 mb-2">3) Listen</h2>
      <div class="bg-slate-800/60 rounded-2xl p-4 border border-slate-700">
        <div id="listenChord" class="flex flex-wrap gap-3 items-center">
          <button id="btnPlayBlock" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white font-semibold">Play Chord (block)</button>
          <button id="btnPlayArp" class="px-4 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 text-white font-semibold">Arpeggiate</button>
          <button id="btnPlayStrum" class="px-4 py-2 rounded-xl bg-rose-600 hover:bg-rose-500 text-white font-semibold hidden">Strum (low‚Üíhigh)</button>
          <div class="text-sm text-slate-400">First click activates audio.</div>
        </div>
        <div id="listenScale" class="hidden items-center gap-3">
          <button id="btnPlayScale" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white font-semibold">Play Scale (asc.)</button>
          <div class="text-sm text-slate-400">Plays two octaves from the tonic.</div>
        </div>
        <div id="listenSel" class="mt-4 flex flex-wrap gap-3 items-center">
          <button id="btnPlaySelChord" disabled class="px-4 py-2 rounded-xl bg-teal-600 hover:bg-teal-500 text-white font-semibold disabled:opacity-50 disabled:cursor-not-allowed">Play Selection (chord)</button>
          <button id="btnPlaySelArp" disabled class="px-4 py-2 rounded-xl bg-cyan-600 hover:bg-cyan-500 text-white font-semibold disabled:opacity-50 disabled:cursor-not-allowed">Play Selection (arp)</button>
        </div>
        <div class="mt-4 flex items-center gap-2">
          <input id="heldSustainSnap" type="checkbox" class="h-4 w-4" checked>
          <label for="heldSustainSnap" class="text-sm text-slate-300">Snap held note sustain to 1/16 note</label>
        </div>
      </div>
    </section>

    <!-- ============ Sequencer ============ -->
    <section id="sequencerHost" class="mb-6 hidden">
      <h2 class="text-lg font-semibold text-slate-100 mb-2">Sequencer</h2>
      <div class="bg-slate-800/60 rounded-2xl p-4 border border-slate-700 space-y-4">
        <div class="flex flex-wrap gap-3 items-center">
          <button id="seqPlay" class="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-white font-semibold">Play</button>
          <button id="seqPause" class="px-4 py-2 rounded-xl bg-yellow-600 hover:bg-yellow-500 text-white font-semibold">Pause</button>
          <button id="seqStop" class="px-4 py-2 rounded-xl bg-rose-600 hover:bg-rose-500 text-white font-semibold">Stop</button>
          <div class="flex items-center gap-2">
            <span id="seqPosition" class="bg-slate-900/80 border border-slate-700 rounded-lg px-3 py-2 font-mono text-sm text-slate-300 min-w-[100px] text-center cursor-pointer hover:bg-slate-800/80" title="Click to jump to position">0:0:0</span>
            <button id="seqToStart" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-white text-sm">|&lt;</button>
            <button id="seqToEnd" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-white text-sm">&gt;|</button>
          </div>
          <label class="flex items-center gap-2 text-sm text-slate-300">
            <input id="seqCountIn" type="checkbox" class="h-4 w-4">Count-in (1 bar)
          </label>
          <label class="text-sm text-slate-300 flex items-center gap-2">BPM
            <input id="seqBpm" type="number" value="120" class="w-20 bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1" />
          </label>
          <label class="flex items-center gap-2 text-sm text-slate-300">
            <input id="seqLoop" type="checkbox" class="h-4 w-4">Loop
          </label>
          <label class="flex items-center gap-2 text-sm text-slate-300">
            <input id="seqClick" type="checkbox" class="h-4 w-4">Click
          </label>
          <label class="flex items-center gap-2 text-sm text-slate-300">
            <input id="seqAutoScroll" type="checkbox" class="h-4 w-4" checked>Auto-scroll
          </label>
          <label class="flex items-center gap-2 text-sm text-slate-300">
            Snap
            <select id="seqQuantize" class="bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1 text-sm">
              <option value="0">Off</option>
              <option value="48">1/4</option>
              <option value="24">1/8</option>
              <option value="12" selected>1/16</option>
              <option value="6">1/32</option>
            </select>
          </label>
          <button id="seqQuantizeBtn" class="px-3 py-1 rounded-lg bg-purple-600 hover:bg-purple-500 text-white text-sm font-medium">Quantize</button>
          <div class="flex items-center gap-1">
            <span class="text-xs text-slate-400">Length:</span>
            <button class="note-length-btn px-2 py-1 text-xs rounded bg-slate-700 hover:bg-slate-600" data-length="192">1/1</button>
            <button class="note-length-btn px-2 py-1 text-xs rounded bg-slate-700 hover:bg-slate-600" data-length="96">1/2</button>
            <button class="note-length-btn px-2 py-1 text-xs rounded bg-slate-700 hover:bg-slate-600 bg-blue-600" data-length="48">1/4</button>
            <button class="note-length-btn px-2 py-1 text-xs rounded bg-slate-700 hover:bg-slate-600" data-length="24">1/8</button>
            <button class="note-length-btn px-2 py-1 text-xs rounded bg-slate-700 hover:bg-slate-600" data-length="12">1/16</button>
          </div>
          <label class="flex items-center gap-2 text-sm text-slate-300">
            TS
            <input id="seqTSNum" type="number" min="1" max="16" value="4" class="w-14 bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1" />
            /
            <input id="seqTSDen" type="number" min="1" max="16" list="tsDenList" value="4" class="w-14 bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1" />
            <datalist id="tsDenList"><option>1</option><option>2</option><option>4</option><option>8</option><option>16</option></datalist>
          </label>
          <label class="flex items-center gap-2 text-sm text-slate-300">Scheme
            <select id="seqColorScheme" class="bg-slate-800/80 border border-slate-700 rounded-lg px-2 py-1">
              <option>Classic</option>
              <option>Pastel</option>
              <option>Neon</option>
              <option>Sunset</option>
              <option>Ocean</option>
            </select>
          </label>
        </div>

        <!-- Pattern Library -->
        <details class="border border-slate-700 rounded-lg">
          <summary class="bg-slate-800/60 px-4 py-2 cursor-pointer hover:bg-slate-700/60 rounded-t-lg font-medium">Pattern Library</summary>
          <div class="p-4 space-y-2">
            <div class="flex gap-2 flex-wrap">
              <button class="pattern-btn px-3 py-1 text-sm rounded bg-emerald-700 hover:bg-emerald-600" data-pattern="kick-basic">Basic Kick</button>
              <button class="pattern-btn px-3 py-1 text-sm rounded bg-rose-700 hover:bg-rose-600" data-pattern="snare-basic">Basic Snare</button>
              <button class="pattern-btn px-3 py-1 text-sm rounded bg-blue-700 hover:bg-blue-600" data-pattern="hihat-basic">Basic Hi-hat</button>
              <button class="pattern-btn px-3 py-1 text-sm rounded bg-purple-700 hover:bg-purple-600" data-pattern="chord-basic">Basic Chord</button>
            </div>
            <div class="flex gap-2">
              <button id="savePatternBtn" class="px-3 py-1 text-sm rounded bg-slate-700 hover:bg-slate-600">Save Pattern</button>
              <button id="exportSelectedBtn" class="px-3 py-1 text-sm rounded bg-slate-700 hover:bg-slate-600">Export Selected</button>
            </div>
          </div>
        </details>

        <div id="seqTracks" class="space-y-2"></div>

        <div id="pianoRollWrap" class="flex">
          <canvas id="pianoRollGutter" class="bg-slate-900 border border-slate-700"></canvas>
          <div id="pianoRollScroll" class="overflow-auto">
            <canvas id="pianoRoll" class="bg-slate-900 border border-slate-700"></canvas>
          </div>
        </div>

        <div class="flex flex-wrap gap-3 items-center">
          <label class="text-sm text-slate-300">Zoom X
            <input id="seqZoomX" type="range" min="0.5" max="8" step="0.1" value="1" class="w-32" />
          </label>
          <label class="text-sm text-slate-300">Zoom Y
            <input id="seqZoomY" type="range" min="0.5" max="2" step="0.1" value="1" class="w-32" />
          </label>
          <button id="seqClearAll" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-white text-sm">Clear All</button>
        </div>

        <div class="flex flex-wrap gap-3 items-center">
          <button id="seqExportJson" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-white text-sm">Export JSON</button>
          <button id="seqImportJson" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-white text-sm">Import JSON</button>
          <input id="seqImportFile" type="file" accept="application/json" class="hidden" />
          <button id="seqExportMid" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-white text-sm">Export MIDI</button>
          <button id="seqExportWav" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-white text-sm">Export WAV</button>
          <button id="seqExportMp3" class="px-3 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-white text-sm">Export MP3</button>
        </div>
        <div id="seqStatus" class="text-xs text-slate-300"></div>
        <div id="seqHotkeys" class="text-xs text-slate-400 space-y-1">
          <div><strong>Selection:</strong> Click note ‚Ä¢ Shift+Click: toggle ‚Ä¢ Ctrl+A: select all ‚Ä¢ Delete: delete selected</div>
          <div><strong>Edit:</strong> Ctrl+C/X/V: copy/cut/paste ‚Ä¢ Ctrl+Z/Y: undo/redo ‚Ä¢ Ctrl+Q: quantize ‚Ä¢ Ctrl+P/T/I: select by pitch/timing/invert ‚Ä¢ Space: play/pause</div>
          <div><strong>View:</strong> Ctrl+Wheel: zoom X ‚Ä¢ Alt+Wheel: zoom Y ‚Ä¢ Shift+Wheel: scroll X</div>
        </div>
      </div>
    </section>

    <!-- ============ 4) Export (de‚Äëemphasized) ============ -->
    <section class="mb-6">
      <h2 class="text-lg font-semibold text-slate-100 mb-2">4) Export (FL Studio)</h2>
      <div class="bg-slate-800/60 rounded-2xl p-4 border border-slate-700">
        <div class="flex flex-wrap gap-3 items-start">
          <button id="btnCopyFL" class="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600 text-white font-semibold">Copy for FL Paste (Score)</button>
          <button id="btnCopyCSV" class="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600 text-white font-semibold">Copy CSV</button>
          <button id="btnMid" class="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600 text-white font-semibold">Download .MID</button>
          <div class="text-xs text-slate-400">Browsers often block non‚Äëtext clipboard formats. If FL‚Äôs Paste is disabled after copying, use <span class="font-semibold">Download .MID</span> and drag into Piano Roll.</div>
        </div>
        <div id="copyStatus" class="text-xs text-slate-300 mt-2"></div>
      </div>
    </section>

    <!-- ============ Tests ============ -->
    <section class="mb-6">
      <h2 class="text-lg font-semibold text-slate-100 mb-2">Automated Self‚ÄëTests (dev)</h2>
      <div id="tests" class="grid grid-cols-1 md:grid-cols-2 gap-2 text-sm"></div>
    </section>

      <footer class="mt-10 text-center text-xs text-slate-500">¬© 2025 ‚Äî Interactive Chord & Scale Library</footer>
  </div>

<script>
// ========================= UTIL: THEORY =========================
// Quarter‚Äëtone pitch map (0.5‚Äësemitone steps = 24 pitch classes)
const NOTES_SHARP = [
  "C","C+","C#","C#+","D","D+","D#","D#+",
  "E","E+","F","F+","F#","F#+","G","G+",
  "G#","G#+","A","A+","A#","A#+","B","B+"
];
const PITCH_STEP = 0.5; // smallest interval in semitones
const OCTAVE = 12;      // semitones per octave
const ENHARMONIC_MAP = {"Db":"C#","Eb":"D#","Gb":"F#","Ab":"G#","Bb":"A#","E#":"F","B#":"C","Fb":"E","Cb":"B"};
const KEYS = ["C","C#","Db","D","D#","Eb","E","F","F#","Gb","G","G#","Ab","A","A#","Bb","B"];
const INSTRUMENTS = [
  "Piano",
  "Guitar",
  "Bass",
  "Violin",
  "Flute",
  "Recorder",
  "Trumpet",
  "Saxophone",
  "Koto",
  "Oud",
  "Ney",
  "Hammond Organ"
];
// Modes and scales. Quarter‚Äëtone maqam patterns based on MaqamWorld theory (https://www.maqamworld.com/)
const MODES = {
  Ionian: [0,2,4,5,7,9,11],
  Dorian: [0,2,3,5,7,9,10],
  Phrygian: [0,1,3,5,7,8,10],
  Lydian: [0,2,4,6,7,9,11],
  Mixolydian: [0,2,4,5,7,9,10],
  Aeolian: [0,2,3,5,7,8,10],
  Locrian: [0,1,3,5,6,8,10],
  "Major Pentatonic": [0,2,4,7,9],
  "Minor Pentatonic": [0,3,5,7,10],
  Blues: [0,3,5,6,7,10],
  // Common maqamat using 24-TET intervals (0.5 = quarter-tone)
  "Maqam Rast": [0,2,3.5,5,7,9,10.5],      // Rast: E half-flat, B half-flat
  "Maqam Bayati": [0,1.5,3,5,7,8.5,10],    // Bayati: D half-flat, B half-flat
  "Maqam Hijaz": [0,1,4,5,7,8,11],         // Hijaz: augmented second between 2nd & 3rd
  "Maqam Saba": [0,1.5,3,4.5,7,8.5,10],    // Saba: D & F half-flat
  "Maqam Nahawand": [0,2,3,5,7,8,10]       // Nahawand: natural minor
};
// Group modes by musical system for UI filtering
const MODE_SYSTEMS = {
  Western: [
    "Ionian","Dorian","Phrygian","Lydian","Mixolydian","Aeolian","Locrian",
    "Major Pentatonic","Minor Pentatonic","Blues"
  ],
  Maqam: ["Maqam Rast","Maqam Bayati","Maqam Hijaz","Maqam Saba","Maqam Nahawand"]
};
const CHORD_QUALITIES = { Maj:[0,4,7], Min:[0,3,7], Dim:[0,3,6], Aug:[0,4,8], Sus2:[0,2,7], Sus4:[0,5,7], "7":[0,4,7,10], Maj7:[0,4,7,11], Min7:[0,3,7,10], m7b5:[0,3,6,10], Dim7:[0,3,6,9] };
function toSharpName(n){ return ENHARMONIC_MAP[n]||n; }
function pcIndex(note){
  const n = String(note).trim();
  const m = n.match(/^([A-G])([#b+-]*)/);
  if(!m) return null;
  const BASE = {C:0, D:2, E:4, F:5, G:7, A:9, B:11};
  let val = BASE[m[1]];
  for(const ch of (m[2]||"")){
    if(ch==="#") val += 1;
    else if(ch==="b") val -= 1;
    else if(ch==="+") val += PITCH_STEP;
    else if(ch==="-") val -= PITCH_STEP;
  }
  return val;
}
function pcName(i){
  const norm = ((i % OCTAVE) + OCTAVE) % OCTAVE;
  const idx = Math.round(norm / PITCH_STEP) % NOTES_SHARP.length;
  return NOTES_SHARP[idx];
}
function midiFrom(note, octave=4){
  const i = pcIndex(note);
  if(i==null) return null;
  return OCTAVE*(octave+1)+i;
}
function buildScale(tonic, modeName){ const rootPc=pcIndex(tonic); const pattern = MODES[modeName]||MODES.Ionian; if(rootPc==null) return []; return pattern.map(iv=> pcName(rootPc + iv)); }
function buildChord(root, quality){ const rootPc=pcIndex(root); const pattern = CHORD_QUALITIES[quality]||CHORD_QUALITIES.Maj; if(rootPc==null) return []; return pattern.map(iv=> pcName(rootPc + iv)); }
function makePcSet(notes){ return new Set(notes.map(pcIndex).filter(x=>x!=null)); }
function mod(n,m){ return ((n % m) + m) % m; }
function chordToMidi(notes, root, baseOct=4){
  const rootMidi = midiFrom(root, baseOct);
  if(rootMidi==null) return [];
  const rootPc = pcIndex(root);
  if(rootPc==null) return [];
  const pcs = notes.map(pcIndex).filter(x=>x!=null);
  const ordered = pcs.map(pc=>{
    let best = rootMidi - mod(rootPc - pc, OCTAVE);
    while(best < rootMidi-5) best += OCTAVE;
    while(best > rootMidi+OCTAVE) best -= OCTAVE;
    return best;
  }).sort((a,b)=>a-b);
  return Array.from(new Set(ordered));
}
function scaleToMidi(scaleNotes, tonic, startOct=4){
  const pcs = scaleNotes.map(pcIndex).filter(x=>x!=null);
  const tonicPc = pcIndex(tonic);
  if(tonicPc==null) return [];
  const seq = [];
  for(let o=startOct; o<=startOct+1; o++){
    for(const pc of pcs){ seq.push(OCTAVE*(o+1)+pc); }
  }
  const startIdx = pcs.indexOf(tonicPc);
  if(startIdx>0){
    const perOct = pcs.length;
    const out=[];
    for(let i=0;i<seq.length;i+=perOct){
      const chunk=seq.slice(i,i+perOct);
      out.push(...chunk.slice(startIdx), ...chunk.slice(0,startIdx));
    }
    return out;
  }
  return seq;
}

// Identify chord from selection
const CHORD_DICT = CHORD_QUALITIES; // reuse
function eqArr(a,b){ return a.length===b.length && a.every((v,i)=>v===b[i]); }
function intersection(a,b){ return a.filter(x=>b.includes(x)); }
function invOf(midiNotes, rootPc){ const bass=Math.min(...midiNotes); const d=mod((bass%OCTAVE)-rootPc,OCTAVE); if(Math.abs(d)<PITCH_STEP/2) return "root position"; if(Math.abs(d-3)<PITCH_STEP/2 || Math.abs(d-4)<PITCH_STEP/2) return "1st inv"; if(Math.abs(d-7)<PITCH_STEP/2 || Math.abs(d-8)<PITCH_STEP/2 || Math.abs(d-6)<PITCH_STEP/2) return "2nd inv"; return "inversion"; }
function chordNameFromNotes(midiNotes){ if(!midiNotes.length) return {name:"‚Äî",detail:""}; const pcs=[...new Set(midiNotes.map(n=>mod(n,OCTAVE)))].sort((a,b)=>a-b); let best=null; for(const root of pcs){ const trans=pcs.map(pc=> mod(pc-root,OCTAVE)).sort((a,b)=>a-b); for(const [qual,pat] of Object.entries(CHORD_DICT)){ const reduced=[...new Set(pat.map(x=>mod(x,OCTAVE)))].sort((a,b)=>a-b); const score=intersection(trans,reduced).length; const exact=eqArr(trans,reduced); if(!best || exact || score>best.score){ best={score,name: pcName(root)+" "+qual, root, inv: invOf(midiNotes, root), exact}; if(exact) return {...best, detail: best.inv?`(${best.inv})`:""}; } } } return best? {...best, detail: (best.inv?`(${best.inv}) `:"")+"~approx"} : {name:"?", detail:""}; }

// ========================= AUDIO (Tone.js) =========================
let _synth=null; let _started=false; const ENV={
  Piano:{a:.002,d:.3,s:.3,r:1.2,osc:'triangle'},
  Guitar:{a:.002,d:.25,s:0,r:1.5,osc:'sawtooth'},
  Bass:{a:.005,d:.25,s:.4,r:.8,osc:'square'},
  Violin:{a:.01,d:.12,s:.7,r:.6,osc:'sawtooth'},
  Flute:{a:.04,d:.12,s:.8,r:.5,osc:'sine'},
  Recorder:{a:.03,d:.15,s:.7,r:.4,osc:'sine'},
  Trumpet:{a:.01,d:.2,s:.6,r:.5,osc:'sawtooth'},
  Saxophone:{a:.02,d:.2,s:.6,r:.3,osc:'sawtooth'},
  Koto:{a:.002,d:.3,s:0,r:1.6,osc:'triangle'},
  Oud:{a:.002,d:.35,s:0,r:1.8,osc:'triangle'},
  Ney:{a:.08,d:.12,s:.7,r:.5,osc:'sine'},
  'Hammond Organ':{a:.03,d:.2,s:.8,r:.7,osc:'square'}
};
const masterLim = new Tone.Limiter(-1).toDestination();
// === SEQUENCER: Audio Engine (melodic & drum registries) ===
function makePoly(env){
  const gain = new Tone.Gain(1).connect(masterLim);
  const synth = new Tone.PolySynth(Tone.Synth,{
    envelope:{attack:env.a,decay:env.d,sustain:env.s,release:env.r},
    oscillator:{type:env.osc}
  }).connect(gain);
  return {
    trigger(midi,time=Tone.now(),velocity=1,dur='8n'){
      try {
        const freq = midiToFreq(midi);
        const vel = Math.max(0.1, Math.min(1, velocity));
        synth.triggerAttackRelease(freq, dur, time, vel);
      } catch(e) {
        console.warn('PolySynth trigger error:', e);
      }
    },
    release(midi,time=Tone.now()){
      try {
        synth.triggerRelease(midiToFreq(midi), time);
      } catch(e) {
        // Ignore release errors
      }
    },
    setVolume(v){ gain.gain.value = Math.max(0, Math.min(1, v)); },
    dispose(){ synth.dispose(); gain.dispose(); }
  };
}

// [fix] poly pluck - improved for guitar, koto, and oud
function makePluck(){
  const gain = new Tone.Gain(1).connect(masterLim);
  const reverb = new Tone.Reverb({decay: 0.3, wet: 0.2}).connect(gain);
  const synth = new Tone.PolySynth(Tone.PluckSynth, {
    attackNoise:0.5,
    dampening:1800,
    resonance:0.8
  }).connect(reverb);
  return {
    trigger(midi,time=Tone.now(),velocity=1,dur='8n'){
      try {
        const freq = midiToFreq(midi);
        const vel = Math.max(0.1, Math.min(1, velocity));
        synth.triggerAttackRelease(freq, dur, time, vel);
      } catch(e) {
        console.warn('PluckSynth trigger error:', e);
      }
    },
    release(midi,time=Tone.now()){
      // PluckSynth doesn't need explicit release
    },
    setVolume(v){ gain.gain.value = Math.max(0, Math.min(1, v)); },
    dispose(){ synth.dispose(); reverb.dispose(); gain.dispose(); }
  };
}

function makeMono(env){
  const gain = new Tone.Gain(1).connect(masterLim);
  const synth = new Tone.MonoSynth({
    oscillator:{type:env.osc},
    envelope:{attack:env.a,decay:env.d,sustain:env.s,release:env.r}
  }).connect(gain);
  return {
    trigger(midi,time=Tone.now(),velocity=1,dur='8n'){
      try {
        const freq = midiToFreq(midi);
        const vel = Math.max(0.1, Math.min(1, velocity));
        synth.triggerAttackRelease(freq, dur, time, vel);
      } catch(e) {
        console.warn('MonoSynth trigger error:', e);
      }
    },
    release(midi,time=Tone.now()){
      try {
        synth.triggerRelease(midiToFreq(midi), time);
      } catch(e) {
        // Ignore release errors
      }
    },
    setVolume(v){ gain.gain.value = v; },
    dispose(){ synth.dispose(); gain.dispose(); }
  };
}

function makeDuo(env){
  const gain = new Tone.Gain(1).connect(masterLim);
  const vibrato = new Tone.Vibrato(4,0.1).connect(gain);
  const synth = new Tone.DuoSynth({
    voice0:{oscillator:{type:env.osc}, envelope:{attack:env.a,decay:env.d,sustain:env.s,release:env.r}},
    voice1:{oscillator:{type:env.osc}, envelope:{attack:env.a,decay:env.d,sustain:env.s,release:env.r}},
    harmonicity:1.01,
    vibratoAmount:0.1,
    vibratoRate:5
  }).connect(vibrato);
  return {
    trigger(midi,time=Tone.now(),velocity=1,dur='8n'){
      try {
        const freq = midiToFreq(midi);
        const vel = Math.max(0.1, Math.min(1, velocity));
        synth.triggerAttackRelease(freq, dur, time, vel);
      } catch(e) {
        console.warn('DuoSynth trigger error:', e);
      }
    },
    release(midi,time=Tone.now()){
      try {
        synth.triggerRelease(midiToFreq(midi), time);
      } catch(e) {
        // Ignore release errors
      }
    },
    setVolume(v){ gain.gain.value = Math.max(0, Math.min(1, v)); },
    dispose(){ synth.dispose(); vibrato.dispose(); gain.dispose(); }
  };
}

function makeAM(env){
  const gain = new Tone.Gain(1).connect(masterLim);
  const reverb = new Tone.Reverb({decay: 1.2, wet: 0.3}).connect(gain);
  const synth = new Tone.AMSynth({
    oscillator:{type:env.osc},
    envelope:{attack:env.a,decay:env.d,sustain:env.s,release:env.r},
    modulationEnvelope:{attack:env.a*0.5,decay:env.d*2,sustain:env.s*0.7,release:env.r},
    modulation:{type:'sine'},
    modulationFrequency:3.5
  }).connect(reverb);
  return {
    trigger(midi,time=Tone.now(),velocity=1,dur='8n'){
      try {
        const freq = midiToFreq(midi);
        const vel = Math.max(0.1, Math.min(1, velocity));
        synth.triggerAttackRelease(freq, dur, time, vel);
      } catch(e) {
        console.warn('AMSynth trigger error:', e);
      }
    },
    release(midi,time=Tone.now()){
      try {
        synth.triggerRelease(midiToFreq(midi), time);
      } catch(e) {
        // Ignore release errors
      }
    },
    setVolume(v){ gain.gain.value = Math.max(0, Math.min(1, v)); },
    dispose(){ synth.dispose(); reverb.dispose(); gain.dispose(); }
  };
}

const SEQ_INSTR = {
  Piano: () => makePoly(ENV.Piano),
  Guitar: () => makePluck(),
  Bass: () => makeMono(ENV.Bass),
  Violin: () => makeDuo(ENV.Violin),
  Flute: () => makeAM(ENV.Flute),
  Recorder: () => makeAM(ENV.Recorder),
  Trumpet: () => makeMono(ENV.Trumpet),
  Saxophone: () => makeDuo(ENV.Saxophone),
  Koto: () => makePluck(),
  Oud: () => makePluck(),
  Ney: () => makeAM(ENV.Ney),
  'Hammond Organ': () => makePoly(ENV['Hammond Organ'])
};

function createSeqInstrument(name){
  try {
    const factory = SEQ_INSTR[name];
    if(factory) {
      return factory();
    }
    
    // Fallback to makePoly with appropriate envelope
    const env = ENV[name] || ENV.Piano;
    return makePoly(env);
  } catch(error) {
    console.error(`Failed to create instrument ${name}:`, error);
    // Ultimate fallback
    return makePoly(ENV.Piano);
  }
}

async function ensureTone(instr){
  if(!_started){
    await Tone.start();
    _started=true;
  }
  if(!_synth){
    _synth = new Tone.PolySynth(Tone.Synth).connect(masterLim);
  }
  const p=ENV[instr]||ENV.Piano;
  _synth.set({ envelope:{attack:p.a, decay:p.d, sustain:p.s, release:p.r}, oscillator:{type:p.osc} });
}
function midiName(m){ const pc=mod(m,OCTAVE), oct=Math.floor(m/OCTAVE)-1; return pcName(pc)+oct; }
// Convert (possibly fractional) MIDI note numbers to Hz
function midiToFreq(m){ return 440 * Math.pow(2, (m - 69) / 12); }

// [fix] press/hold piano
function pressHeld(midi){
  ensureTone(instrument).then(()=>{
    _synth.triggerAttack(midiToFreq(midi));
  });
}
function releaseHeld(midi){
  ensureTone(instrument).then(()=>{
    const now=Tone.now();
    const beat=60/tempo;
    const sixteenth=beat/4;
    const t=heldSustainSnap.checked? Math.ceil(now/sixteenth)*sixteenth : now;
    _synth.triggerRelease(midiToFreq(midi), t);
  });
}
function allNotesOff(){ _synth?.releaseAll(); }
window.addEventListener('blur', allNotesOff);

// Global keyboard shortcuts
document.addEventListener('keydown', (ev) => {
  // Don't interfere with input fields
  if(ev.target.tagName === 'INPUT' || ev.target.tagName === 'TEXTAREA') return;
  
  const ctrl = ev.ctrlKey || ev.metaKey;
  
  switch(ev.code) {
    case 'Space':
      ev.preventDefault();
      if(sequencerState === 'playing') {
        seqPause.click();
      } else {
        seqPlay.click();
      }
      break;
      
    case 'Escape':
      ev.preventDefault();
      seqStop.click();
      break;
      
    case 'Delete':
    case 'Backspace':
      ev.preventDefault();
      deleteSelected();
      break;
      
    case 'KeyA':
      if(ctrl) {
        ev.preventDefault();
        selectAll();
      }
      break;
      
    case 'KeyC':
      if(ctrl) {
        ev.preventDefault();
        copySelected();
      }
      break;
      
    case 'KeyX':
      if(ctrl) {
        ev.preventDefault();
        cutSelected();
      }
      break;
      
    case 'KeyV':
      if(ctrl) {
        ev.preventDefault();
        pasteNotes();
      }
      break;
      
    case 'KeyZ':
      if(ctrl && !ev.shiftKey) {
        ev.preventDefault();
        undo();
      }
      break;
      
    case 'KeyY':
      if(ctrl) {
        ev.preventDefault();
        redo();
      }
      break;
      
    case 'KeyZ':
      if(ctrl && ev.shiftKey) {
        ev.preventDefault();
        redo();
      }
      break;
      
    case 'KeyQ':
      if(ctrl) {
        ev.preventDefault();
        quantizeSelected();
      }
      break;
      
    case 'KeyP':
      if(ctrl) {
        ev.preventDefault();
        selectByPitch();
      }
      break;
      
    case 'KeyT':
      if(ctrl) {
        ev.preventDefault();
        selectByTiming();
      }
      break;
      
    case 'KeyI':
      if(ctrl) {
        ev.preventDefault();
        invertSelection();
      }
      break;
  }
});

// Undo/Redo system
function saveState(description) {
  const state = {
    tracks: song.tracks.map(t => ({
      ...t,
      clips: t.clips.map(c => ({
        ...c,
        notes: c.notes.map(n => ({...n}))
      }))
    })),
    description
  };
  undoStack.push(state);
  if(undoStack.length > MAX_UNDO) undoStack.shift();
  redoStack.length = 0; // Clear redo stack
  
  // Trigger auto-save
  scheduleAutoSave();
}

function undo() {
  if(undoStack.length === 0) return;
  const currentState = {
    tracks: song.tracks.map(t => ({
      ...t,
      clips: t.clips.map(c => ({
        ...c,
        notes: c.notes.map(n => ({...n}))
      }))
    })),
    description: 'current'
  };
  redoStack.push(currentState);
  
  const prevState = undoStack.pop();
  song.tracks = prevState.tracks;
  selectedNotes.clear();
  drawPianoRoll();
  if(Tone.Transport.state==='started') scheduleSong();
}

function redo() {
  if(redoStack.length === 0) return;
  const currentState = {
    tracks: song.tracks.map(t => ({
      ...t,
      clips: t.clips.map(c => ({
        ...c,
        notes: c.notes.map(n => ({...n}))
      }))
    })),
    description: 'current'
  };
  undoStack.push(currentState);
  
  const nextState = redoStack.pop();
  song.tracks = nextState.tracks;
  selectedNotes.clear();
  drawPianoRoll();
  if(Tone.Transport.state==='started') scheduleSong();
}

// Selection helpers
function selectAll() {
  selectedNotes.clear();
  const track = song.tracks[activeTrack];
  track.clips[0].notes.forEach(note => selectedNotes.add(note));
  drawPianoRoll();
}

function deleteSelected() {
  if(selectedNotes.size === 0) return;
  saveState('Delete notes');
  const track = song.tracks[activeTrack];
  track.clips[0].notes = track.clips[0].notes.filter(note => !selectedNotes.has(note));
  selectedNotes.clear();
  drawPianoRoll();
  if(Tone.Transport.state==='started') scheduleSong(activeTrack);
}

function copySelected() {
  if(selectedNotes.size === 0) return;
  clipboard = Array.from(selectedNotes).map(note => ({...note}));
}

function cutSelected() {
  copySelected();
  deleteSelected();
}

function pasteNotes() {
  if(clipboard.length === 0) return;
  saveState('Paste notes');
  
  const track = song.tracks[activeTrack];
  const minTick = Math.min(...clipboard.map(n => n.tick));
  const playheadTick = Math.round(Tone.Transport.ticks / quantizeSnap) * quantizeSnap;
  
  selectedNotes.clear();
  clipboard.forEach(note => {
    const newNote = {
      ...note,
      tick: playheadTick + (note.tick - minTick)
    };
    track.clips[0].notes.push(newNote);
    selectedNotes.add(newNote);
  });
  
  track.clips[0].notes.sort((a,b) => a.tick - b.tick);
  drawPianoRoll();
  if(Tone.Transport.state==='started') scheduleSong(activeTrack);
}

// Quantization
function quantizeSelected() {
  if(selectedNotes.size === 0) return;
  saveState('Quantize notes');
  
  selectedNotes.forEach(note => {
    note.tick = Math.round(note.tick / quantizeSnap) * quantizeSnap;
  });
  
  const track = song.tracks[activeTrack];
  track.clips[0].notes.sort((a,b) => a.tick - b.tick);
  drawPianoRoll();
  if(Tone.Transport.state==='started') scheduleSong(activeTrack);
}

// Mouse coordinate conversion helper
function getCanvasCoordinates(ev) {
  const rect = pianoRoll.getBoundingClientRect();
  const xCss = ev.clientX - rect.left;
  const yCss = ev.clientY - rect.top;
  const x = xCss + pianoRollScroll.scrollLeft;
  const y = yCss + pianoRollScroll.scrollTop;
  return {x, y, xCss, yCss};
}

function canvasToMusical(x, y) {
  const cellW = 20 * ui.zoomX;
  const cellH = 20 * ui.zoomY;
  const tick = Math.floor(x / cellW) * SIXTEENTH;
  const midi = MAX_MIDI - 1 - Math.floor(y / cellH);
  return {tick, midi};
}

function isPointInNote(x, y, note) {
  const cellW = 20 * ui.zoomX;
  const cellH = 20 * ui.zoomY;
  const noteX = note.tick / SIXTEENTH * cellW;
  const noteW = note.dur / SIXTEENTH * cellW;
  const noteY = (MAX_MIDI - note.midi - 1) * cellH;
  return x >= noteX && x < noteX + noteW && y >= noteY && y < noteY + cellH;
}

// Transport position display
function ticksToBarsBeatsTicks(ticks) {
  const ppq = song.ppq;
  const beatsPerBar = song.ts.num;
  const ticksPerBeat = ppq;
  const ticksPerBar = beatsPerBar * ticksPerBeat;
  
  const bars = Math.floor(ticks / ticksPerBar);
  const beats = Math.floor((ticks % ticksPerBar) / ticksPerBeat);
  const ticksRemainder = ticks % ticksPerBeat;
  
  return `${bars + 1}:${beats + 1}:${ticksRemainder.toString().padStart(3, '0')}`;
}

function updatePositionDisplay() {
  if(seqPosition) {
    const currentTicks = Tone.Transport.ticks;
    seqPosition.textContent = ticksToBarsBeatsTicks(currentTicks);
  }
}

function jumpToStart() {
  Tone.Transport.position = 0;
  updatePositionDisplay();
  drawPianoRoll();
}

function jumpToEnd() {
  // Find the last note across all tracks
  const lastTick = Math.max(0, ...song.tracks.flatMap(t => 
    t.clips[0].notes.map(n => n.tick + n.dur)
  ));
  Tone.Transport.ticks = lastTick;
  updatePositionDisplay();
  drawPianoRoll();
}

// Simple Tone.js drum recipes
function makeMembrane(pitch, opts){
  const gain = new Tone.Gain(1).connect(masterLim);
  const synth = new Tone.MembraneSynth(opts).connect(gain);
  return {
    trigger(note, time=Tone.now(), velocity=1, duration='8n'){
      try {
        const vel = Math.max(0.1, Math.min(1, velocity));
        synth.triggerAttackRelease(pitch, duration, time, vel);
      } catch(e) {
        console.warn('MembraneSynth trigger error:', e);
      }
    },
    setVolume(v){ gain.gain.value = Math.max(0, Math.min(1, v)); },
    dispose(){ synth.dispose(); gain.dispose(); }
  };
}
function makeNoise(filterOpts, envOpts){
  const gain = new Tone.Gain(1).connect(masterLim);
  const filter = new Tone.Filter(filterOpts).connect(gain);
  const synth = new Tone.NoiseSynth({envelope: envOpts}).connect(filter);
  return {
    trigger(note, time=Tone.now(), velocity=1, duration='16n'){
      try {
        const vel = Math.max(0.1, Math.min(1, velocity));
        synth.triggerAttackRelease(duration, time, vel);
      } catch(e) {
        console.warn('NoiseSynth trigger error:', e);
      }
    },
    setVolume(v){ gain.gain.value = Math.max(0, Math.min(1, v)); },
    dispose(){ synth.dispose(); filter.dispose(); gain.dispose(); }
  };
}
function makeMetal(opts){
  const gain = new Tone.Gain(1).connect(masterLim);
  const synth = new Tone.MetalSynth(opts).connect(gain);
  return {
    trigger(note, time=Tone.now(), velocity=1, duration='8n'){
      synth.triggerAttackRelease(duration, time, velocity);
    },
    setVolume(v){ gain.gain.value = v; },
    dispose(){ synth.dispose(); gain.dispose(); }
  };
}
function makeClap({filterFreq, bursts, decay}){
  const gain = new Tone.Gain(1).connect(masterLim);
  const filter = new Tone.Filter({type:'bandpass', frequency:filterFreq, Q:1}).connect(gain);
  const noise = new Tone.NoiseSynth({envelope:{attack:0.001, decay:decay, sustain:0}}).connect(filter);
  return {
    trigger(note, time=Tone.now(), velocity=1){
      for(let i=0;i<bursts;i++){
        noise.triggerAttackRelease('16n', time + i*0.02, velocity);
      }
    },
    setVolume(v){ gain.gain.value = v; },
    dispose(){ noise.dispose(); filter.dispose(); gain.dispose(); }
  };
}
const DRUMS = {
  'Kick 808': () => makeMembrane('C1',{pitchDecay:.05,octaves:4,envelope:{attack:.001,decay:.5,sustain:0,release:.1}}),
  'Kick Punchy': () => makeMembrane('C1',{pitchDecay:.01,octaves:2,envelope:{attack:.001,decay:.2,sustain:0,release:.05}}),
  'Kick Soft': () => makeMembrane('C1',{pitchDecay:.02,octaves:2,envelope:{attack:.002,decay:.3,sustain:0,release:.2}}),
  'Snare Tight': () => makeNoise({type:'highpass',frequency:1800},{attack:.001,decay:.15,sustain:0}),
  'Snare Crack': () => makeNoise({type:'bandpass',frequency:2000},{attack:.001,decay:.1,sustain:0}),
  'Snare Brush': () => makeNoise({type:'lowpass',frequency:1200},{attack:.005,decay:.3,sustain:0}),
  'Cymbal ClosedHat': () => makeMetal({frequency:400,envelope:{attack:.001,decay:.1,release:.01}}),
  'Cymbal OpenHat': () => makeMetal({frequency:300,envelope:{attack:.001,decay:.4,release:.2}}),
  'Cymbal Ride': () => makeMetal({frequency:250,envelope:{attack:.001,decay:1.2,release:.5},harmonicity:5.1,resonance:7e3}),
  'Clap Short': () => makeClap({filterFreq:1200,bursts:2,decay:.15}),
  'Clap Wide': () => makeClap({filterFreq:1200,bursts:3,decay:.25}),
  'Clap Vintage': () => makeClap({filterFreq:800,bursts:4,decay:.3}),
  'Hand Conga': () => makeMembrane('E3',{pitchDecay:.008,octaves:1.5,envelope:{attack:.001,decay:.3,sustain:0,release:.1}}),
  'Hand Bongo': () => makeMembrane('A3',{pitchDecay:.005,octaves:1.5,envelope:{attack:.001,decay:.2,sustain:0,release:.05}}),
  'Hand Tabla': () => makeMembrane('D3',{pitchDecay:.01,octaves:2.5,envelope:{attack:.001,decay:.4,sustain:0,release:.15}})
};
const DRUM_NAMES = Object.keys(DRUMS);
// Plays MIDI notes using the synth. Notes are sequenced by default;
// use `asChord` to trigger them simultaneously or `strum` for a quick
// guitar-style roll.
async function playMidiNotes(list, {instrument='Piano', tempo=110, asChord=false, strum=false, noteDur}={}){
  await ensureTone(instrument);
  const beat=60/tempo;
  const now=Tone.now();
  if(asChord){
    _synth.triggerAttackRelease(list.map(midiToFreq), beat*2, now);
    return;
  }
  if(strum){
    list.forEach((m,i)=>{
      const t=now + i*(beat/6);
      _synth.triggerAttackRelease(midiToFreq(m), beat*1.2, t);
    });
    return;
  }
  if(noteDur!==undefined && list.length===1){
    _synth.triggerAttackRelease(midiToFreq(list[0]), noteDur, now);
    return;
  }
  const seq=list;
  seq.forEach((m,i)=>{
    const t=now + i*(beat*0.6);
    _synth.triggerAttackRelease(midiToFreq(m), beat*0.9, t);
  });
}
// Limitation: only oscillator-based synth; sample instruments would require per-voice pitch bend.

// ========================= MIDI (SMF Type 0) =========================
function encVarLen(v){ let buffer=v & 0x7F; const out=[]; while((v >>= 7)){ buffer <<= 8; buffer |= ((v & 0x7F) | 0x80); } while(true){ out.push(buffer & 0xFF); if(buffer & 0x80) buffer >>= 8; else break; } return new Uint8Array(out); }
const u32=n=>new Uint8Array([(n>>>24)&255,(n>>>16)&255,(n>>>8)&255,n&255]); const u16=n=>new Uint8Array([(n>>>8)&255,n&255]); const strBytes=s=> new TextEncoder().encode(s);
function buildMidi(noteEvents, ppq=96, bpm=130){ const hd=new Uint8Array([...strBytes('MThd'),...u32(6),...u16(0),...u16(1),...u16(ppq)]); const uspq=Math.round(60000000/bpm); const tempo=new Uint8Array([0x00,0xFF,0x51,0x03,(uspq>>>16)&255,(uspq>>>8)&255,uspq&255]); noteEvents.sort((a,b)=>a.start-b.start); let t=0; const ev=[]; for(const e of noteEvents){ const onTicks=Math.round(e.start*ppq)-t; t+=onTicks; ev.push(...encVarLen(onTicks), 0x90, e.midi&127, (e.vel??100)&127); const offTicks=Math.round(e.dur*ppq); ev.push(...encVarLen(offTicks), 0x80, e.midi&127, 0); } ev.push(0x00,0xFF,0x2F,0x00); const trkData=new Uint8Array([...tempo, ...ev]); const trk=new Uint8Array([...strBytes('MTrk'), ...u32(trkData.length), ...trkData]); return new Uint8Array([...hd, ...trk]); }
async function copyBytesToClipboard(bytes){ const status=document.getElementById('copyStatus'); if(window.ClipboardItem){ try{ const item=new ClipboardItem({'audio/midi': new Blob([bytes],{type:'audio/midi'})}); await navigator.clipboard.write([item]); status.textContent='‚úÖ Copied MIDI bytes. In FL: Piano roll ‚Üí Edit ‚Üí Paste from clipboard (Score).'; return true; }catch(e){ status.textContent='‚ö†Ô∏è Browser blocked binary clipboard. Use Download .MID instead.'; return false; } } else { status.textContent='‚ö†Ô∏è ClipboardItem not available. Use Download .MID.'; return false; } }

// ========================= UI STATE =========================
const $ = (sel)=>document.querySelector(sel);
const pianoHost = $('#pianoHost'); const guitarHost = $('#guitarHost'); const bassHost = $('#bassHost'); const violinHost = $('#violinHost'); const fluteHost = $('#fluteHost'); const recorderHost = $('#recorderHost'); const trumpetHost = $('#trumpetHost'); const saxophoneHost = $('#saxophoneHost'); const kotoHost = $('#kotoHost'); const neyHost = $('#neyHost');
const selKey = $('#selKey'); const selQuality = $('#selQuality'); const selMode = $('#selMode'); const selInstr = $('#selInstr'); const selSystem = $('#selSystem');
const badgeRoot = $('#badgeRoot'); const badgeChordNotes = $('#badgeChordNotes'); const badgeScaleNotes = $('#badgeScaleNotes');
const badgeId = $('#badgeId'); const badgeSelNotes = $('#badgeSelNotes');
const btnModeChord = $('#btnModeChord'); const btnModeScale = $('#btnModeScale'); const btnModeSequencer = $('#btnModeSequencer');
const wrapChord = $('#wrapChord'); const wrapScale = $('#wrapScale');
const listenChord = $('#listenChord'); const listenScale = $('#listenScale'); const btnPlayStrum = $('#btnPlayStrum');
const btnPlaySelChord = $('#btnPlaySelChord'); const btnPlaySelArp = $('#btnPlaySelArp');
const heldSustainSnap = $('#heldSustainSnap');
const tempoInput = $('#tempo');
const sequencerHost = $('#sequencerHost');
const seqPlay = $('#seqPlay'); const seqPause = $('#seqPause'); const seqStop = $('#seqStop'); const seqBpm = $('#seqBpm');
const seqLoop = $('#seqLoop'); const seqClick = $('#seqClick');
const seqAutoScroll = $('#seqAutoScroll');
const seqQuantize = $('#seqQuantize');
const seqQuantizeBtn = $('#seqQuantizeBtn');
const seqPosition = $('#seqPosition');
const seqToStart = $('#seqToStart');
const seqToEnd = $('#seqToEnd');
const seqCountIn = $('#seqCountIn');
const noteLengthBtns = document.querySelectorAll('.note-length-btn');
let selectedNoteLength = 48; // Default to 1/4 note
let countInId = null;

// Pattern library
const PATTERN_LIBRARY = {
  'kick-basic': [
    {tick: 0, dur: 48, midi: 36, vel: 0.9},        // C2 - Kick on 1
    {tick: 192, dur: 48, midi: 36, vel: 0.8},      // Kick on 2
    {tick: 384, dur: 48, midi: 36, vel: 0.9},      // Kick on 3
    {tick: 576, dur: 48, midi: 36, vel: 0.8}       // Kick on 4
  ],
  'snare-basic': [
    {tick: 192, dur: 48, midi: 38, vel: 0.9},      // D2 - Snare on 2
    {tick: 576, dur: 48, midi: 38, vel: 0.8}       // Snare on 4
  ],
  'hihat-basic': [
    {tick: 0, dur: 24, midi: 42, vel: 0.6},        // F#2 - Closed hi-hat on 1
    {tick: 96, dur: 24, midi: 42, vel: 0.4},       // and off-beats
    {tick: 192, dur: 24, midi: 42, vel: 0.5},
    {tick: 288, dur: 24, midi: 42, vel: 0.4},
    {tick: 384, dur: 24, midi: 42, vel: 0.6},
    {tick: 480, dur: 24, midi: 42, vel: 0.4},
    {tick: 576, dur: 24, midi: 42, vel: 0.5},
    {tick: 672, dur: 24, midi: 42, vel: 0.4}
  ],
  'chord-basic': [
    {tick: 0, dur: 384, midi: 60, vel: 0.7},       // C4 - C major chord
    {tick: 0, dur: 384, midi: 64, vel: 0.6},       // E4
    {tick: 0, dur: 384, midi: 67, vel: 0.6},       // G4
    {tick: 384, dur: 384, midi: 57, vel: 0.7},     // A3 - A minor chord  
    {tick: 384, dur: 384, midi: 60, vel: 0.6},     // C4
    {tick: 384, dur: 384, midi: 64, vel: 0.6}      // E4
  ]
};

// Auto-save functionality
let autoSaveTimer = null;
const AUTO_SAVE_DELAY = 10000; // 10 seconds after last edit
const seqTSNum = $('#seqTSNum'); const seqTSDen = $('#seqTSDen');
const seqColorScheme = $('#seqColorScheme');
const pianoRoll = $('#pianoRoll');
const pianoRollGutter = $('#pianoRollGutter');
const pianoRollScroll = $('#pianoRollScroll');
const seqTracks = $('#seqTracks');
const seqZoomX = $('#seqZoomX'); const seqZoomY = $('#seqZoomY');
const seqClearAll = $('#seqClearAll');
const seqExportJson = $('#seqExportJson');
const seqImportJson = $('#seqImportJson');
const seqImportFile = $('#seqImportFile');
const seqExportMid = $('#seqExportMid');
const seqExportWav = $('#seqExportWav');
const seqExportMp3 = $('#seqExportMp3');
const seqStatus = $('#seqStatus');
const seqHotkeys = $('#seqHotkeys');
pianoRollScroll.addEventListener('scroll', ()=>{
  ui.scrollX = pianoRollScroll.scrollLeft;
  ui.scrollY = pianoRollScroll.scrollTop;
  pianoRollGutter.scrollTop = ui.scrollY;
});

let mode = 'Chord';
let instrument = 'Piano';
let keyRoot = 'C';
let chordQuality = 'Maj';
let scaleMode = 'Ionian';
let system = 'Western';
let tempo = 120;
let fluteLeftToRight = true;
let recorderLeftToRight = true;
let neyLeftToRight = true;
let fluteOrientation = 'horizontal';
let recorderOrientation = 'horizontal';
let neyOrientation = 'horizontal';
let trumpetLeftToRight = true;
let trumpetOrientation = 'horizontal';
let saxophoneLeftToRight = true;
let saxophoneOrientation = 'horizontal';

// Selection for chord identification
const selection = new Set(); // midi numbers

// === SEQUENCER: Data Model & Store ===
const defaultSeqTracks = ['Piano','Guitar','Bass','Kick 808','Snare Tight','Cymbal ClosedHat','Clap Short','Hand Conga'];

/**
 * @typedef {Object} SeqNote
 * @property {number} tick    Note start position in ticks
 * @property {number} dur     Duration in ticks
 * @property {number} midi    MIDI note number
 * @property {number} vel     Velocity from 0‚Äì1
 */

/**
 * @typedef {Object} SeqClip
 * @property {number} start   Clip start in ticks
 * @property {number} length  Clip length in ticks
 * @property {SeqNote[]} notes
 */

/**
 * @typedef {Object} SeqTrack
 * @property {string} instrument
 * @property {SeqClip[]} clips
 * @property {boolean} mute
 * @property {boolean} solo
 * @property {number} vol
 * @property {?Object} player
 */

/**
 * @typedef {Object} SeqSong
 * @property {number} ppq
 * @property {number} bpm
 * @property {[number,number]} loop   // measure range [start,end)
 * @property {SeqTrack[]} tracks
 */

/** @type {SeqSong} */
const song = {
  ppq: 192,
  bpm: 120,
  ts:{num:4,den:4},
  loop:{enabled:false,start:0,end:192*16},
  tracks: defaultSeqTracks.map((name,i) => ({
    id:'trk'+i,
    name: name,  // Editable track name
    instrument: name,
    clips: [{ id:'clip0', start:0, length:192*64, loop:false, notes: [] }],
    mute:false,
    solo:false,
    volume:0.8,
    color:'',
    colorOverridden: false,
    player:null,
    part:null
  }))
};

Tone.Transport.PPQ = song.ppq;

const SIXTEENTH = song.ppq / 4;
let lastNoteDur = song.ppq * song.ts.num;
const MIN_MIDI = midiFrom('C',2);
const MAX_MIDI = MIN_MIDI + 4*12;
let activeTrack = 0;
let dragNote = null;
let trackSwitchTimeout = null;
const TRACK_SWITCH_DELAY = 500;
const ui = {zoomX:1, zoomY:1, scrollX:0, scrollY:0, scheme:'Classic', selecting:false, selectStart:{x:0,y:0}};

// [fix] active track highlight
function refreshActiveTrackHighlight(){
  [...seqTracks.children].forEach((r,i)=>r.classList.toggle('bg-orange-500/20', i===activeTrack));
}

// === SEQUENCER: Color Schemes & Per-Track Colors ===
const SEQ_COLOR_SCHEMES = {
  Classic:['#60a5fa','#f472b6','#34d399','#f59e0b','#a78bfa','#f87171','#22d3ee','#c084fc'],
  Pastel:['#93c5fd','#fbcfe8','#bbf7d0','#fde68a','#ddd6fe','#fecaca','#a5f3fc','#f5d0fe'],
  Neon:['#3b82f6','#ec4899','#10b981','#f59e0b','#8b5cf6','#ef4444','#06b6d4','#a855f7'],
  Sunset:['#fb7185','#f59e0b','#fbbf24','#fca5a5','#f472b6','#a78bfa','#60a5fa','#38bdf8'],
  Ocean:['#0ea5e9','#38bdf8','#22d3ee','#10b981','#14b8a6','#34d399','#60a5fa','#818cf8']
};
function applySeqColorScheme(name){
  const scheme=SEQ_COLOR_SCHEMES[name]||SEQ_COLOR_SCHEMES.Classic;
  song.tracks.forEach((t,i)=>{ if(!t.colorOverridden){ t.color=scheme[i%scheme.length]; }});
  [...seqTracks.children].forEach((row,i)=>{
    const inp=row.querySelector('input[type="color"]');
    if(inp && !song.tracks[i].colorOverridden) inp.value=song.tracks[i].color;
  });
  seqColorScheme.value=name;
  refreshActiveTrackHighlight();
}

function setBpm(val){
  song.bpm = tempo = val;
  tempoInput.value = seqBpm.value = String(val);
  Tone.Transport.bpm.value = val;
}

function updateLoop(){
  // Clear any existing auto-stop
  if(autoStopId) {
    Tone.Transport.clear(autoStopId);
    autoStopId = null;
  }
  
  if(seqLoop.checked && song.loop.enabled) {
    Tone.Transport.loopStart = `${song.loop.start}i`;
    Tone.Transport.loopEnd = `${song.loop.end}i`;
    Tone.Transport.loop = true;
  } else {
    // For one-shot playback, disable looping
    Tone.Transport.loop = false;
    // Compute last note end across all tracks; fallback to at least 16 bars
    const ends = song.tracks.flatMap(t =>
      t.clips.flatMap(c => c.notes.map(n => c.start + n.tick + n.dur))
    );
    const maxNoteTick = ends.length ? Math.max(...ends) : 192 * 16;
    // Schedule a stop event at the end of the song
    autoStopId = Tone.Transport.scheduleOnce(() => {
      if(sequencerState === 'playing') {
        seqStop.click();
      }
    }, `${maxNoteTick + 192}i`); // Add small buffer
  }
}

function scheduleSong(changedIdx){
  const anySolo = song.tracks.some(t => t.solo);
  song.tracks.forEach((track, idx) => {
    const active = anySolo ? track.solo : !track.mute;
    if(!active){
      if(track.part) {
        track.part.dispose();
        track.part = null;
      }
      return;
    }

    // Create player if needed
    if(!track.player){
      try {
        const drumFactory = DRUMS[track.instrument];
        track.player = drumFactory ? drumFactory() : createSeqInstrument(track.instrument);
        if(track.player && track.player.setVolume) {
          track.player.setVolume(track.volume ?? 0.8);
        }
      } catch(error) {
        console.error(`Failed to create player for ${track.instrument}:`, error);
        // Create fallback player
        track.player = createSeqInstrument('Piano');
        track.player.setVolume?.(track.volume ?? 0.8);
      }
    }

    if(changedIdx !== undefined && changedIdx !== idx && track.part){
      if(seqLoop.checked && song.loop.enabled) {
        track.part.loopStart = `${song.loop.start}i`;
        track.part.loopEnd = `${song.loop.end}i`;
        track.part.loop = true;
      } else {
        track.part.loop = false;
      }
      return;
    }

    // Dispose existing part
    if(track.part) {
      track.part.dispose();
      track.part = null;
    }
    
    // Collect all notes from all clips
    const events = [];
    track.clips.forEach(clip => {
      clip.notes.forEach(note => {
        const when = clip.start + note.tick;
        events.push([`${when}i`, note]);
      });
    });

    // Create part only if there are events
    if(events.length > 0){
      try {
        track.part = new Tone.Part((time, n) => {
          if(track.player && track.player.trigger) {
            track.player.trigger(n.midi, time, n.vel ?? 0.8, `${n.dur}i`);
          }
        }, events);
        if(seqLoop.checked && song.loop.enabled) {
          track.part.loopStart = `${song.loop.start}i`;
          track.part.loopEnd = `${song.loop.end}i`;
          track.part.loop = true;
        } else {
          track.part.loop = false;
        }
        track.part.start(0);
      } catch(error) {
        console.error(`Failed to create part for track ${idx}:`, error);
        track.part = null;
      }
    }
  });
}

let clickId = null;
let sequencerState = 'stopped'; // 'stopped', 'playing', 'paused'
let autoStopId = null; // Store the auto-stop event ID

// Selection and editing state
let selectedNotes = new Set(); // Set of note objects
let clipboard = []; // Copied notes
let undoStack = []; // Undo history
let redoStack = []; // Redo history
const MAX_UNDO = 50;
let quantizeSnap = SIXTEENTH; // Current quantization snap

setBpm(song.bpm);
updateLoop();

function serializeSong(){
  return JSON.stringify(song, (k,v)=> (k==='player' || k==='part') ? undefined : v);
}

function loadSong(data){
  song.ppq = data.ppq;
  song.bpm = data.bpm;
  song.ts = data.ts || song.ts;
  song.loop = data.loop || song.loop;
  song.tracks = data.tracks.map(t=>({ ...t, player:null, part:null }));
  Tone.Transport.PPQ = song.ppq;
  setBpm(song.bpm);
  updateLoop();
  initSequencer();
  drawPianoRoll();
  if(Tone.Transport.state==='started') scheduleSong();
}

function exportSongMidi(){
  // Type-0 merged MIDI. TODO: implement Type-1 multi-track export.
  const events = [];
  song.tracks.forEach(track=>{
    track.clips.forEach(clip=>{
      clip.notes.forEach(n=>{
        events.push({
          start:(clip.start + n.tick)/song.ppq,
          dur:n.dur/song.ppq,
          midi:n.midi,
          vel:Math.round((n.vel ?? 0.8)*127)
        });
      });
    });
  });
  const bytes = buildMidi(events, song.ppq, song.bpm);
  const blob = new Blob([bytes],{type:'audio/midi'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download='song.mid';
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url),1500);
}

function hexToRgba(hex,a){ const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16); return `rgba(${r},${g},${b},${a})`; }
function drawPianoRoll(){
  const clip = song.tracks[activeTrack].clips[0];
  // Auto-extend clip length if needed based on actual notes
  const maxNoteTick = Math.max(0, ...song.tracks.flatMap(t => 
    t.clips[0].notes.map(n => n.tick + n.dur)
  ));
  const minClipLength = Math.max(clip.length, maxNoteTick + 192*4); // Add 4 bars buffer
  if(minClipLength > clip.length) {
    song.tracks.forEach(t => t.clips[0].length = minClipLength);
  }
  const steps = clip.length / SIXTEENTH;
  const noteCount = MAX_MIDI - MIN_MIDI;
  const cellW = 20 * ui.zoomX;
  const cellH = 20 * ui.zoomY;
  const width = steps * cellW;
  const height = noteCount * cellH;
  const dpr = window.devicePixelRatio||1;
  pianoRoll.width = width*dpr; pianoRoll.height = height*dpr; pianoRoll.style.width=width+'px'; pianoRoll.style.height=height+'px';
  const ctx = pianoRoll.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0); ctx.clearRect(0,0,width,height);
  // background lanes
  for(let i=0;i<noteCount;i++){ ctx.fillStyle = i%2? '#243341':'#23303c'; ctx.fillRect(0,i*cellH,width,cellH); }
  // grid vertical
  for(let i=0;i<=steps;i++){
    const x=i*cellW; ctx.strokeStyle='#2d3c4a'; if(i%(song.ppq/ SIXTEENTH)===0) ctx.strokeStyle='#395063'; if(i%(song.ts.num*song.ppq/SIXTEENTH)===0) ctx.strokeStyle='#4a6379'; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke();
  }
  // horizontal lines
  for(let j=0;j<=noteCount;j++){ const y=j*cellH; ctx.strokeStyle='#2d3c4a'; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke(); }
  // notes
  song.tracks.forEach((track,idx)=>{
    track.clips[0].notes.forEach(n=>{
      const x=n.tick/SIXTEENTH*cellW;
      const w=n.dur/SIXTEENTH*cellW;
      const y=(MAX_MIDI-n.midi-1)*cellH;
      
      // Highlight selected notes
      if(idx === activeTrack && selectedNotes.has(n)) {
        ctx.fillStyle = '#ff6b9d'; // Pink highlight for selected notes
        ctx.fillRect(x-2, y-2, w+4, cellH+4);
      }
      
      // Velocity visualization - darker = louder
      const velocity = n.vel || 0.8;
      const opacity = idx === activeTrack ? velocity : velocity * 0.3;
      const baseColor = track.color || '#60a5fa';
      ctx.fillStyle = hexToRgba(baseColor, opacity);
      ctx.fillRect(x,y,w,cellH);
      
      // Velocity indicator bar (thin line at bottom of note)
      if(idx === activeTrack) {
        ctx.fillStyle = hexToRgba(baseColor, 1);
        const velHeight = Math.max(1, velocity * 4);
        ctx.fillRect(x, y + cellH - velHeight, w, velHeight);
      }
    });
  });
  if(dragNote){
    ctx.fillStyle='rgba(236,72,153,0.6)';
    const x=dragNote.tick/SIXTEENTH*cellW; const w=dragNote.dur/SIXTEENTH*cellW; const y=(MAX_MIDI-dragNote.midi-1)*cellH; ctx.fillRect(x,y,w,cellH);
  }
  
  // Loop markers (if loop is enabled)
  if(song.loop.enabled) {
    const loopStartX = song.loop.start / SIXTEENTH * cellW;
    const loopEndX = song.loop.end / SIXTEENTH * cellW;
    
    // Loop region highlight
    ctx.fillStyle = 'rgba(16, 185, 129, 0.05)';
    ctx.fillRect(loopStartX, 0, loopEndX - loopStartX, height);
    
    // Loop start marker
    ctx.strokeStyle = '#10b981';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(loopStartX, 0);
    ctx.lineTo(loopStartX, height);
    ctx.stroke();
    
    // Loop end marker  
    ctx.strokeStyle = '#ef4444';
    ctx.beginPath();
    ctx.moveTo(loopEndX, 0);
    ctx.lineTo(loopEndX, height);
    ctx.stroke();
  }
  
  // Selection rectangle
  if(ui.selecting) {
    ctx.strokeStyle = '#ff6b9d';
    ctx.fillStyle = 'rgba(255, 107, 157, 0.1)';
    ctx.lineWidth = 2;
    const rectX = Math.min(ui.selectStart.x, ui.selectEnd.x);
    const rectY = Math.min(ui.selectStart.y, ui.selectEnd.y);
    const rectW = Math.abs(ui.selectEnd.x - ui.selectStart.x);
    const rectH = Math.abs(ui.selectEnd.y - ui.selectStart.y);
    ctx.fillRect(rectX, rectY, rectW, rectH);
    ctx.strokeRect(rectX, rectY, rectW, rectH);
  }
  // gutter
  const gctx = pianoRollGutter.getContext('2d');
  pianoRollGutter.width = 60*dpr; pianoRollGutter.height = height*dpr; pianoRollGutter.style.width='60px'; pianoRollGutter.style.height=height+'px';
  gctx.setTransform(dpr,0,0,dpr,0,0); gctx.clearRect(0,0,60,height);
  for(let i=0;i<noteCount;i++){ const y=i*cellH; gctx.fillStyle = i%2? '#243341':'#23303c'; gctx.fillRect(0,y,60,cellH); gctx.fillStyle='#cbd5e1'; const m=MAX_MIDI-1-i; gctx.fillText(midiName(m),5,y+12); }
}

function cancelTrackSwitch(){
  if(trackSwitchTimeout){ clearTimeout(trackSwitchTimeout); trackSwitchTimeout=null; }
  pianoRoll.removeEventListener('pointerup', cancelTrackSwitch);
  pianoRoll.removeEventListener('pointerleave', cancelTrackSwitch);
  pianoRoll.removeEventListener('pointercancel', cancelTrackSwitch);
}

function startTrackSwitchTimer(idx){
  cancelTrackSwitch();
  trackSwitchTimeout = setTimeout(()=>{
    activeTrack = idx;
    refreshActiveTrackHighlight();
    seqStatus.textContent = `Painting: ${song.tracks[activeTrack].instrument} ‚Ä¢ ${song.ts.num}/${song.ts.den}`;
    drawPianoRoll();
    cancelTrackSwitch();
  }, TRACK_SWITCH_DELAY);
  pianoRoll.addEventListener('pointerup', cancelTrackSwitch);
  pianoRoll.addEventListener('pointerleave', cancelTrackSwitch);
  pianoRoll.addEventListener('pointercancel', cancelTrackSwitch);
}

pianoRoll.addEventListener('contextmenu', ev => {
  ev.preventDefault(); // Prevent browser context menu
  
  const coords = getCanvasCoordinates(ev);
  const clip = song.tracks[activeTrack].clips[0];
  
  // Find if we right-clicked on a note
  let foundNote = null;
  for(let i = clip.notes.length - 1; i >= 0; i--) {
    const n = clip.notes[i];
    if(isPointInNote(coords.x, coords.y, n)) {
      foundNote = n;
      break;
    }
  }
  
  if(foundNote) {
    // Select the note if it's not already selected
    if(!selectedNotes.has(foundNote)) {
      selectedNotes.clear();
      selectedNotes.add(foundNote);
      drawPianoRoll();
    }
    
    // Show context menu at mouse position
    showContextMenu(ev.clientX, ev.clientY, foundNote);
  }
});

pianoRoll.addEventListener('pointerdown', ev => {
  cancelTrackSwitch();
  const coords = getCanvasCoordinates(ev);
  const musical = canvasToMusical(coords.x, coords.y);
  const {x, y} = coords;
  const {tick, midi} = musical;
  const cellW = 20*ui.zoomX; const cellH = 20*ui.zoomY;
  // check notes from non-active tracks for potential track switch
  for(let t=0;t<song.tracks.length;t++){
    if(t===activeTrack) continue;
    const oClip = song.tracks[t].clips[0];
    for(let i=oClip.notes.length-1;i>=0;i--){
      const n=oClip.notes[i];
      if(isPointInNote(x, y, n)){
        startTrackSwitchTimer(t);
        return;
      }
    }
  }
  const clip=song.tracks[activeTrack].clips[0];
  // check existing notes first
  let foundNote = null;
  for(let i=clip.notes.length-1;i>=0;i--){
    const n=clip.notes[i];
    if(isPointInNote(x, y, n)){
      foundNote = n;
      break;
    }
  }
  
  if(foundNote) {
    if(ev.shiftKey && ev.altKey) {
      // Shift+Alt = Delete note
      saveState('Delete note');
      clip.notes.splice(clip.notes.indexOf(foundNote), 1);
      selectedNotes.delete(foundNote);
      drawPianoRoll();
      if(Tone.Transport.state==='started') scheduleSong(activeTrack);
      return;
    } else if(ev.shiftKey) {
      // Shift+Click = Toggle selection
      if(selectedNotes.has(foundNote)) {
        selectedNotes.delete(foundNote);
      } else {
        selectedNotes.add(foundNote);
      }
      drawPianoRoll();
      return;
    } else if(ev.ctrlKey || ev.metaKey) {
      // Ctrl+Click = Add to selection
      selectedNotes.add(foundNote);
      drawPianoRoll();
      return;
    } else if(!selectedNotes.has(foundNote)) {
      // Regular click on unselected note = Select only this note
      selectedNotes.clear();
      selectedNotes.add(foundNote);
      previewNote(foundNote.midi, foundNote.vel);
      drawPianoRoll();
    } else {
      // Clicking on already selected note = preview it
      previewNote(foundNote.midi, foundNote.vel);
    }
    
    // Start dragging if note is selected
    if(selectedNotes.has(foundNote)) {
      const noteX=foundNote.tick/SIXTEENTH*cellW;
      const noteW=foundNote.dur/SIXTEENTH*cellW;
      const nearRight = x>noteX+noteW-5; // resize handle ~5px
      saveState(nearRight ? 'Resize note' : 'Move note');
      dragNote={note:foundNote, mode:nearRight?'resize':'move', offsetTick:tick-foundNote.tick, offsetMidi:midi-foundNote.midi};
      pianoRoll.setPointerCapture(ev.pointerId);
      drawPianoRoll();
      return;
    }
  } else {
    // Clicked on empty space
    if(ev.shiftKey) {
      // Start selection rectangle
      ui.selecting = true;
      ui.selectStart = {x, y};
      ui.selectEnd = {x, y};
      pianoRoll.setPointerCapture(ev.pointerId);
      drawPianoRoll();
      return;
    } else if(!ev.ctrlKey && !ev.metaKey) {
      selectedNotes.clear();
      drawPianoRoll();
    }
  }
  
  // Don't create new note if we're starting a selection
  if(!ui.selecting) {
    // otherwise create new note
    const snappedTick = quantizeSnap > 0 ? Math.round(tick / quantizeSnap) * quantizeSnap : tick;
    const noteDur = selectedNoteLength || lastNoteDur;
    dragNote={tick:snappedTick, dur:noteDur, midi, mode:'new'};
    pianoRoll.setPointerCapture(ev.pointerId);
    drawPianoRoll();
  }
});
pianoRoll.addEventListener('pointermove', ev=>{
  const coords = getCanvasCoordinates(ev);
  const {x, y} = coords;
  
  if(ui.selecting) {
    // Update selection rectangle
    ui.selectEnd = {x, y};
    drawPianoRoll();
    return;
  }
  
  if(!dragNote) return;
  const musical = canvasToMusical(x, y);
  const {tick, midi} = musical;
  const cellW=20*ui.zoomX;
  if(dragNote.mode==='new'){
    let endTick=Math.floor(x/cellW+1)*SIXTEENTH;
    if(quantizeSnap > 0) {
      endTick = Math.round(endTick / quantizeSnap) * quantizeSnap;
    }
    dragNote.dur=Math.max(quantizeSnap || SIXTEENTH, endTick-dragNote.tick);
  } else if(dragNote.mode==='move'){
    let newTick = Math.max(0,tick-dragNote.offsetTick);
    if(quantizeSnap > 0) {
      newTick = Math.round(newTick / quantizeSnap) * quantizeSnap;
    }
    const newMidi = Math.min(MAX_MIDI-1,Math.max(0,midi-dragNote.offsetMidi));
    
    // If multiple notes are selected, move them all relative to the dragged note
    if(selectedNotes.size > 1) {
      const tickDelta = newTick - dragNote.note.tick;
      const midiDelta = newMidi - dragNote.note.midi;
      
      selectedNotes.forEach(note => {
        if(note !== dragNote.note) {
          note.tick = Math.max(0, note.tick + tickDelta);
          note.midi = Math.min(MAX_MIDI-1, Math.max(0, note.midi + midiDelta));
        }
      });
    }
    
    dragNote.note.tick = newTick;
    dragNote.note.midi = newMidi;
  } else if(dragNote.mode==='resize'){
    const endTick=Math.floor(x/cellW+1)*SIXTEENTH; dragNote.note.dur=Math.max(SIXTEENTH,endTick-dragNote.note.tick);
  }
  drawPianoRoll();
});
pianoRoll.addEventListener('pointerup', ev=>{
  const coords = getCanvasCoordinates(ev);
  const {x, y} = coords;
  
  if(ui.selecting) {
    // Complete selection rectangle
    const cellW = 20 * ui.zoomX;
    const cellH = 20 * ui.zoomY;
    
    const startTick = Math.min(ui.selectStart.x, x) / cellW * SIXTEENTH;
    const endTick = Math.max(ui.selectStart.x, x) / cellW * SIXTEENTH;
    const startMidi = MAX_MIDI - 1 - Math.max(ui.selectStart.y, y) / cellH;
    const endMidi = MAX_MIDI - 1 - Math.min(ui.selectStart.y, y) / cellH;
    
    const track = song.tracks[activeTrack];
    const wasEmpty = selectedNotes.size === 0;
    
    track.clips[0].notes.forEach(note => {
      if(note.tick >= startTick && note.tick < endTick && 
         note.midi >= startMidi && note.midi <= endMidi) {
        selectedNotes.add(note);
      }
    });
    
    ui.selecting = false;
    drawPianoRoll();
    pianoRoll.releasePointerCapture(ev.pointerId);
    return;
  }
  
  if(!dragNote) return; const track=song.tracks[activeTrack];
  if(dragNote.mode==='new') {
    saveState('Add note');
    const newNote = {tick:dragNote.tick,dur:dragNote.dur,midi:dragNote.midi,vel:0.8};
    track.clips[0].notes.push(newNote);
    selectedNotes.clear();
    selectedNotes.add(newNote);
    lastNoteDur = dragNote.dur;
  } else if(dragNote.mode === 'move' || dragNote.mode === 'resize') {
    // Save state was already called on pointerdown for existing notes
  }
  // keep notes ordered after edits
  track.clips[0].notes.sort((a,b)=>a.tick-b.tick);
  dragNote=null; drawPianoRoll(); if(Tone.Transport.state==='started') scheduleSong(activeTrack); pianoRoll.releasePointerCapture(ev.pointerId);
});
pianoRoll.addEventListener('pointercancel', ()=>{ dragNote=null; drawPianoRoll(); });

pianoRoll.addEventListener('wheel', ev=>{
  if(ev.ctrlKey){ ev.preventDefault(); ui.zoomX=Math.min(8,Math.max(0.5,ui.zoomX*(ev.deltaY>0?0.9:1.1))); seqZoomX.value=ui.zoomX; drawPianoRoll(); }
  else if(ev.altKey){ ev.preventDefault(); ui.zoomY=Math.min(2,Math.max(0.5,ui.zoomY*(ev.deltaY>0?0.9:1.1))); seqZoomY.value=ui.zoomY; drawPianoRoll(); }
  else if(ev.shiftKey){ pianoRollScroll.scrollLeft += ev.deltaY; ev.preventDefault(); }
});

let playheadReq=null;
function startPlayhead(){
  function loop(){
    const cellW=20*ui.zoomX;
    const x=Tone.Transport.ticks/SIXTEENTH*cellW;
    if(seqAutoScroll.checked){ pianoRollScroll.scrollLeft = x - pianoRollScroll.clientWidth/2; }
    updatePositionDisplay();
    drawPianoRoll();
    playheadReq=requestAnimationFrame(loop);
  }
  loop();
}
function stopPlayhead(){ 
  if(playheadReq) cancelAnimationFrame(playheadReq); 
  playheadReq=null; 
  updatePositionDisplay();
  drawPianoRoll(); 
}

function initSequencer(){
  seqTracks.innerHTML='';
  song.tracks.forEach((track, idx) => {
    const row=document.createElement('div');
    row.className='flex items-center gap-2';
    const instrOpts = INSTRUMENTS.map(t=>`<option${t===track.instrument?' selected':''}>${t}</option>`).join('');
    const drumOpts = DRUM_NAMES.map(t=>`<option${t===track.instrument?' selected':''}>${t}</option>`).join('');
    row.innerHTML=
      `<div class="flex items-center gap-2 min-w-[180px]">`+
        `<input type="text" class="track-name bg-transparent border-none text-slate-200 font-medium cursor-pointer hover:bg-slate-800/50 px-2 py-1 rounded w-24" value="${track.name || track.instrument}" readonly title="Double-click to edit">`+
        `<button class="mute-btn w-8 h-8 text-sm font-bold rounded ${track.mute ? 'bg-rose-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}" data-mute>M</button>`+
        `<button class="solo-btn w-8 h-8 text-sm font-bold rounded ${track.solo ? 'bg-emerald-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}" data-solo>S</button>`+
      `</div>`+
      `<input type="range" min="0" max="1" step="0.01" value="${track.volume}" class="w-20" title="Volume: ${Math.round(track.volume*100)}%"/>`+
      `<select class="bg-slate-800/80 border border-slate-700 rounded px-2 py-1 text-sm">`+
      instrOpts+
      `<optgroup label="Drums (Sequencer)">${drumOpts}</optgroup>`+
      `</select>`+
      `<input type="color" id="trk-${idx}-color" class="w-6 h-6 rounded border border-slate-600" value="${track.color||'#60a5fa'}" title="Track color">`+
      `<button id="trk-${idx}-clrReset" class="px-2 py-1 text-xs rounded bg-slate-700 hover:bg-slate-600" title="Reset color">‚Üª</button>`;
    seqTracks.appendChild(row);
    const nameInput = row.querySelector('.track-name');
    const muteBtn = row.querySelector('[data-mute]');
    const soloBtn = row.querySelector('[data-solo]');
    const volSlider = row.querySelector('input[type="range"]');
    const sel = row.querySelector('select');
    const clrInput = row.querySelector(`#trk-${idx}-color`);
    const clrReset = row.querySelector(`#trk-${idx}-clrReset`);
    
    // Editable track name
    nameInput.addEventListener('dblclick', () => {
      nameInput.readOnly = false;
      nameInput.focus();
      nameInput.select();
      nameInput.classList.add('bg-slate-800', 'border', 'border-blue-500');
    });
    
    nameInput.addEventListener('blur', () => {
      nameInput.readOnly = true;
      nameInput.classList.remove('bg-slate-800', 'border', 'border-blue-500');
      track.name = nameInput.value.trim() || track.instrument;
      nameInput.value = track.name;
    });
    
    nameInput.addEventListener('keydown', (e) => {
      if(e.key === 'Enter') {
        nameInput.blur();
      } else if(e.key === 'Escape') {
        nameInput.value = track.name || track.instrument;
        nameInput.blur();
      }
    });
    muteBtn.addEventListener('click', (e)=>{
      track.mute = !track.mute;
      if(track.mute) {
        muteBtn.className = 'mute-btn w-8 h-8 text-sm font-bold rounded bg-rose-600 text-white';
      } else {
        muteBtn.className = 'mute-btn w-8 h-8 text-sm font-bold rounded bg-slate-700 text-slate-300 hover:bg-slate-600';
      }
      if(Tone.Transport.state==='started') scheduleSong();
    });
    soloBtn.addEventListener('click', ()=>{
      track.solo = !track.solo;
      if(track.solo) {
        soloBtn.className = 'solo-btn w-8 h-8 text-sm font-bold rounded bg-emerald-600 text-white';
      } else {
        soloBtn.className = 'solo-btn w-8 h-8 text-sm font-bold rounded bg-slate-700 text-slate-300 hover:bg-slate-600';
      }
      if(Tone.Transport.state==='started') scheduleSong();
    });
    volSlider.addEventListener('input', e=>{
      track.volume = Number(e.target.value);
      volSlider.title = `Volume: ${Math.round(track.volume*100)}%`;
      if(track.player && track.player.setVolume) track.player.setVolume(track.volume);
    });
    sel.addEventListener('change', e=>{
      track.instrument = e.target.value;
      // Update track name only if it hasn't been customized
      if(!track.name || track.name === nameInput.value) {
        track.name = track.instrument;
        nameInput.value = track.name;
      }
      if(track.player){ track.player.dispose(); track.player=null; }
      if(Tone.Transport.state==='started') scheduleSong(idx);
    });
    clrInput.addEventListener('input', e=>{
      track.color = e.target.value;
      track.colorOverridden = true;
      drawPianoRoll();
    });
    clrReset.addEventListener('click', ()=>{
      track.colorOverridden = false;
      applySeqColorScheme(seqColorScheme.value);
      drawPianoRoll();
    });
    row.addEventListener('click', e=>{
      if(['BUTTON','INPUT','SELECT'].includes(e.target.tagName)) return;
      activeTrack = idx;
      refreshActiveTrackHighlight();
      seqStatus.textContent = `Painting: ${song.tracks[activeTrack].instrument} ‚Ä¢ ${song.ts.num}/${song.ts.den}`;
      drawPianoRoll();
    });
  });
  applySeqColorScheme('Classic');
  refreshActiveTrackHighlight();
  seqStatus.textContent = `Painting: ${song.tracks[activeTrack].instrument} ‚Ä¢ ${song.ts.num}/${song.ts.den}`;
  drawPianoRoll();
}

function updateSelButtons(){
  const empty = selection.size === 0;
  btnPlaySelChord.disabled = empty;
  btnPlaySelArp.disabled = empty;
}

// Build selects
function fillSelect(el, arr){ el.innerHTML = arr.map(v=>`<option value="${v}">${v}</option>`).join(''); }
fillSelect(selKey, KEYS); selKey.value = keyRoot; fillSelect(selInstr, INSTRUMENTS); selInstr.value=instrument;
fillSelect(selQuality, Object.keys(CHORD_QUALITIES)); selQuality.value=chordQuality;
fillSelect(selSystem, Object.keys(MODE_SYSTEMS)); selSystem.value = system;
function populateModeOptions(){
  fillSelect(selMode, MODE_SYSTEMS[system]);
  if(!MODE_SYSTEMS[system].includes(scaleMode)) scaleMode = MODE_SYSTEMS[system][0];
  selMode.value = scaleMode;
}
populateModeOptions();

function updateBadges(){
  badgeRoot.textContent = 'Root: '+toSharpName(keyRoot);
  const selected = computeSelected();
  if(mode==='Chord'){ badgeChordNotes.textContent = 'Notes: '+selected.notes.join('-'); }
  else { badgeScaleNotes.textContent = 'Scale: '+selected.notes.join('-'); }
  const arr=[...selection].sort((a,b)=>a-b);
  const id=chordNameFromNotes(arr);
  badgeId.textContent = 'Selection: '+id.name+(id.detail?(' '+id.detail):'');
  badgeSelNotes.textContent = 'Notes: ' + (arr.length? arr.map(m=> pcName(mod(m,OCTAVE))+(Math.floor(m/OCTAVE)-1)).join(' '): '‚Äî');
  updateSelButtons();
}

function computeSelected(){ if(mode==='Chord'){ const notes=buildChord(keyRoot, chordQuality); return {type:'chord', notes, pcset:makePcSet(notes), rootPc: pcIndex(keyRoot)}; } else { const notes=buildScale(keyRoot, scaleMode); return {type:'scale', notes, pcset:makePcSet(notes), rootPc: pcIndex(keyRoot)}; } }

// ========================= PIANO =========================
// === HELD-SUSTAIN: Piano pointer handlers ===
function buildPiano(){ pianoHost.innerHTML=''; const container=document.createElement('div'); container.className='relative mx-auto select-none'; const shell=document.createElement('div'); shell.className='relative h-48 bg-slate-900 border border-slate-700 rounded-xl p-2'; container.appendChild(shell);
  // White keys row
  const startMidi=midiFrom('C',3); const endMidi=midiFrom('F',5); const keys=[]; for(let m=startMidi;m<=endMidi;m++) keys.push(m); const whites=keys.filter(m=>![1,3,6,8,10].includes(mod(m,OCTAVE)));
  const whiteRow=document.createElement('div'); whiteRow.className='flex h-full'; shell.appendChild(whiteRow);
  whites.forEach(m=>{ const pc=mod(m,OCTAVE); const k=document.createElement('div'); k.dataset.midi=String(m); k.dataset.pc=String(pc); k.className='white-key relative flex-1 mx-0.5 rounded-b-xl border bg-white border-slate-400'; const lbl=document.createElement('div'); lbl.className='absolute inset-x-0 bottom-1 text-center text-[10px] text-slate-700 select-none'; lbl.textContent = pcName(pc)+(Math.floor(m/OCTAVE)-1); k.appendChild(lbl);
    k.addEventListener('pointerdown', (ev)=>{ if(ev.shiftKey){ toggleSelect(m); updateBadges(); renderHighlights(); } else { pressHeld(m); k.setPointerCapture(ev.pointerId); k.dataset.held='1'; } });
    const end=(ev)=>{ if(!k.dataset.held) return; releaseHeld(m); delete k.dataset.held; updateBadges(); renderHighlights(); };
    k.addEventListener('pointerup', end); k.addEventListener('pointercancel', end);
    whiteRow.appendChild(k); });
  // Black overlay (pointer-enabled only on keys)
  const overlay=document.createElement('div'); overlay.className='pointer-events-none absolute left-2 right-2 top-2 bottom-2 flex'; shell.appendChild(overlay);
  keys.filter(m=>[1,3,6,8,10].includes(mod(m,OCTAVE))).forEach(m=>{ const pc=mod(m,OCTAVE); const wrap=document.createElement('div'); wrap.className='relative w-[6.66%] mx-[1.67%]'; wrap.style.visibility = [1,3,6,8,10].includes(pc)?'visible':'hidden'; const blk=document.createElement('div'); blk.dataset.midi=String(m); blk.dataset.pc=String(pc); blk.className='black-key absolute left-1/2 -translate-x-1/2 w-3/5 h-2/3 rounded-b-lg border bg-black border-black pointer-events-auto'; blk.title = pcName(pc)+(Math.floor(m/OCTAVE)-1); const lbl=document.createElement('div'); lbl.className='absolute inset-x-0 bottom-1 text-center text-[9px] text-rose-200 font-bold select-none'; lbl.textContent=''; blk.appendChild(lbl);
    blk.addEventListener('pointerdown', (ev)=>{ if(ev.shiftKey){ toggleSelect(m); updateBadges(); renderHighlights(); } else { pressHeld(m); blk.setPointerCapture(ev.pointerId); blk.dataset.held='1'; } });
    const end=(ev)=>{ if(!blk.dataset.held) return; releaseHeld(m); delete blk.dataset.held; updateBadges(); renderHighlights(); };
    blk.addEventListener('pointerup', end); blk.addEventListener('pointercancel', end);
    wrap.appendChild(blk); overlay.appendChild(wrap); });
  pianoHost.appendChild(container);
}
function toggleSelect(m){ if(selection.has(m)) selection.delete(m); else selection.add(m); }
function clearSelection(){ selection.clear(); updateBadges(); renderHighlights(); }
function renderHighlights(){ const {pcset, rootPc} = computeSelected(); // visual highlight comes from chosen chord/scale
  // Whites (robust selector ‚Äî no Tailwind arbitrary value in query)
  pianoHost.querySelectorAll('.white-key').forEach((el)=>{ const m=Number(el.dataset.midi); const pc=mod(m,OCTAVE); const active=pcset.has(pc); el.className = 'white-key relative flex-1 mx-0.5 rounded-b-xl border '+(active? 'bg-amber-200 border-amber-500':'bg-white border-slate-400');
    const rootBadge = el.querySelector('.rootbadge'); if(rootBadge) rootBadge.remove(); if(rootPc===pc){ const b=document.createElement('div'); b.className='rootbadge absolute inset-x-0 bottom-1 text-center text-[10px] text-rose-600 font-bold'; b.textContent='ROOT'; el.appendChild(b); } });
  // Blacks (robust selector)
  pianoHost.querySelectorAll('.black-key').forEach((el)=>{ const m=Number(el.dataset.midi); const pc=mod(m,OCTAVE); const active=pcset.has(pc); el.className = 'black-key absolute left-1/2 -translate-x-1/2 w-3/5 h-2/3 rounded-b-lg border '+(active? 'bg-indigo-400 border-indigo-600':'bg-black border-black')+' pointer-events-auto'; const r=el.querySelector('.rootchar'); if(r) r.remove(); if(rootPc===pc){ const rr=document.createElement('div'); rr.className='rootchar absolute inset-x-0 bottom-1 text-center text-[9px] text-rose-200 font-bold'; rr.textContent='R'; el.appendChild(rr); } });
}

// ========================= FRETBOARDS =========================
const GUITAR_STD=[40,45,50,55,59,64]; const BASS_STD=[28,33,38,43]; const VIOLIN_TUNING=[55,62,69,76]; const KOTO_TUNING=[60,62,64,67,69,72,74,76,79,81,84,86,88];
function buildFretboard(host, tuning, title){ host.innerHTML=''; const outer=document.createElement('div'); outer.className='w-full'; const titleEl=document.createElement('div'); titleEl.className='text-sm text-slate-300 mb-2'; titleEl.textContent = `${title} ‚Ä¢ Tuning: ` + tuning.map(m=> pcName(mod(m,OCTAVE))+(Math.floor(m/OCTAVE)-1)).join(' '); outer.appendChild(titleEl); const box=document.createElement('div'); box.className='bg-slate-900 rounded-xl border border-slate-700 p-3'; const grid=document.createElement('div'); grid.className='grid'; const frets=13; grid.style.gridTemplateColumns = `repeat(${frets+1}, minmax(0,1fr))`; box.appendChild(grid); // header row
  grid.appendChild(document.createElement('div')); for(let f=0; f<frets; f++){ const d=document.createElement('div'); d.className='text-center text-[10px] text-slate-400'; d.textContent=String(f); grid.appendChild(d); }
  const {pcset, rootPc} = computeSelected(); const strings=tuning.length; for(let s=0; s<strings; s++){ const stringIndex=strings-1-s; const openMidi=tuning[stringIndex]; const lab=document.createElement('div'); lab.className='text-right pr-2 text-[11px] text-slate-400'; lab.textContent=pcName(mod(openMidi,OCTAVE)); grid.appendChild(lab); for(let f=0; f<frets; f++){ const midi=openMidi+f; const pc=mod(midi,OCTAVE); const cell=document.createElement('div'); cell.className='relative h-10 border border-slate-700/70'; if(pcset.has(pc)){ const dot=document.createElement('div'); dot.className = 'absolute inset-1 rounded-full flex items-center justify-center text-[10px] font-semibold '+ (rootPc===pc? 'bg-rose-500/80 text-white':'bg-emerald-400/80 text-black'); dot.title = `${pcName(pc)} @ string ${stringIndex+1}, fret ${f}`; dot.textContent = (rootPc===pc? 'R': pcName(pc)); cell.appendChild(dot); } grid.appendChild(cell); } }
  outer.appendChild(box); const note=document.createElement('div'); note.className='mt-2 text-center text-xs text-slate-400'; note.textContent='Colored dots = playable notes on that string/fret. Red = root.'; outer.appendChild(note); host.appendChild(outer); }

function buildKotoBoard(){ kotoHost.innerHTML=''; const outer=document.createElement('div'); outer.className='w-full'; const titleEl=document.createElement('div'); titleEl.className='text-sm text-slate-300 mb-2'; titleEl.textContent='Koto ‚Ä¢ Tuning: '+KOTO_TUNING.map(m=> pcName(mod(m,OCTAVE))+(Math.floor(m/OCTAVE)-1)).join(' '); outer.appendChild(titleEl); const board=document.createElement('div'); board.className='bg-slate-900 rounded-xl border border-slate-700 p-3'; const {pcset, rootPc} = computeSelected(); KOTO_TUNING.forEach((m)=>{ const pc=mod(m,OCTAVE); const row=document.createElement('div'); row.className='relative h-5 my-1 flex items-center'; const line=document.createElement('div'); line.className='w-full h-0.5'; line.style.backgroundColor = pcset.has(pc)? (rootPc===pc? '#f43f5e':'#4ade80') : '#cbd5e1'; row.appendChild(line); const lab=document.createElement('div'); lab.className='absolute -left-2 -translate-x-full text-xs text-slate-400'; lab.textContent=pcName(pc)+(Math.floor(m/OCTAVE)-1); row.appendChild(lab); if(pcset.has(pc)){ const dot=document.createElement('div'); dot.className='absolute right-0 top-1/2 -translate-y-1/2 px-1 text-[10px] font-semibold rounded '+(rootPc===pc? 'bg-rose-500/80 text-white':'bg-emerald-400/80 text-black'); dot.textContent = rootPc===pc? 'R': pcName(pc); row.appendChild(dot); } board.appendChild(row); }); outer.appendChild(board); kotoHost.appendChild(outer); }

// ========================= FLUTE CHART =========================
const FLUTE_FINGERINGS = {
  // Accurate flute fingerings for first octave (middle C and up)
  // [thumb, index, middle, ring, pinky, right pinky] - 1=covered, 0=open
  C:[1,1,1,1,1,1],     // All holes covered
  'C#':[1,1,1,1,1,0],  // Open right pinky
  D:[1,1,1,1,0,0],     // Open both pinkies
  'D#':[1,1,1,0,1,1],  // Open ring finger
  E:[1,1,1,0,0,0],     // Open ring and pinkies
  F:[1,1,0,0,0,0],     // Open middle, ring, pinkies
  'F#':[1,0,1,0,0,0],  // Thumb + middle only
  G:[1,0,0,0,0,0],     // Thumb only
  'G#':[0,1,1,1,0,0],  // No thumb, close first three
  A:[0,1,1,0,0,0],     // No thumb, index + middle
  'A#':[0,1,0,0,0,0],  // Index finger only
  B:[0,0,1,0,0,0]      // Middle finger only
};
/*
  Flute chart layout
  - ViewBox: 0 0 160 60 (overall diagram size)
  - Hole spacing: i*22 (horizontal positioning)
  - Hole radius: r=10
  Change these numbers to resize the chart or adjust hole placement for custom layouts.
*/
function buildFluteChart(){
  const {rootPc} = computeSelected();
  const note = pcName(rootPc);
  const sharp = ENHARMONIC_MAP[note] || note;
  const fing = FLUTE_FINGERINGS[sharp] || [0,0,0,0,0,0];
  fluteHost.innerHTML='';
  const svgNS='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(svgNS,'svg');
  const isHoriz = fluteOrientation === 'horizontal';
  svg.setAttribute('viewBox', isHoriz ? '0 0 200 80' : '0 0 80 200');
  svg.setAttribute('class','mx-auto drop-shadow-lg');
  
  // Create flute body
  const body = document.createElementNS(svgNS, 'rect');
  if(isHoriz) {
    body.setAttribute('x', '10');
    body.setAttribute('y', '35');
    body.setAttribute('width', '180');
    body.setAttribute('height', '10');
  } else {
    body.setAttribute('x', '35');
    body.setAttribute('y', '10');
    body.setAttribute('width', '10');
    body.setAttribute('height', '180');
  }
  body.setAttribute('fill', '#94a3b8');
  body.setAttribute('stroke', '#64748b');
  body.setAttribute('stroke-width', '2');
  body.setAttribute('rx', '5');
  svg.appendChild(body);
  
  // Add finger holes
  fing.forEach((closed,i)=>{
    const c=document.createElementNS(svgNS,'circle');
    let x,y;
    if(isHoriz){
      x = fluteLeftToRight ? 30 + i*25 : 170 - i*25;
      y = 40;
    } else {
      y = fluteLeftToRight ? 30 + i*25 : 170 - i*25;
      x = 40;
    }
    c.setAttribute('cx', String(x));
    c.setAttribute('cy', String(y));
    c.setAttribute('r','8');
    c.setAttribute('stroke', closed ? '#fbbf24' : '#64748b');
    c.setAttribute('stroke-width','3');
    c.setAttribute('fill', closed ? '#fbbf24' : '#1e293b');
    // Add subtle shadow effect
    c.setAttribute('filter', 'drop-shadow(1px 1px 2px rgba(0,0,0,0.3))');
    svg.appendChild(c);
    
    // Add finger number labels
    const label = document.createElementNS(svgNS, 'text');
    label.setAttribute('x', String(x));
    label.setAttribute('y', isHoriz ? String(y + 20) : String(x + 20));
    label.setAttribute('text-anchor', 'middle');
    label.setAttribute('font-size', '10');
    label.setAttribute('fill', '#94a3b8');
    label.textContent = String(i + 1);
    svg.appendChild(label);
  });
  
  // Add embouchure hole (mouthpiece)
  const embouchure = document.createElementNS(svgNS, 'ellipse');
  if(isHoriz) {
    embouchure.setAttribute('cx', fluteLeftToRight ? '15' : '185');
    embouchure.setAttribute('cy', '40');
    embouchure.setAttribute('rx', '6');
    embouchure.setAttribute('ry', '3');
  } else {
    embouchure.setAttribute('cx', '40');
    embouchure.setAttribute('cy', fluteLeftToRight ? '15' : '185');
    embouchure.setAttribute('rx', '3');
    embouchure.setAttribute('ry', '6');
  }
  embouchure.setAttribute('fill', '#e11d48');
  embouchure.setAttribute('stroke', '#be123c');
  embouchure.setAttribute('stroke-width', '2');
  svg.appendChild(embouchure);
  
  fluteHost.appendChild(svg);
  const flip=document.createElement('button');
  flip.id='fluteFlip';
  flip.textContent = isHoriz ? 'Flip ‚Üî' : 'Flip ‚Üï';
  flip.className='mt-2 text-xs px-2 py-1 border border-slate-700 rounded';
  fluteHost.appendChild(flip);
  const orient=document.createElement('button');
  orient.id='fluteOrient';
  orient.textContent = fluteOrientation === 'horizontal' ? 'Vertical' : 'Horizontal';
  orient.className='mt-2 ml-2 text-xs px-2 py-1 border border-slate-700 rounded';
  fluteHost.appendChild(orient);
  const lbl=document.createElement('div');
  lbl.className='mt-2 text-center text-xs text-slate-400';
  lbl.textContent=`Fingering for ${sharp}`;
  fluteHost.appendChild(lbl);
  document.getElementById('fluteFlip').onclick = () => {
    fluteLeftToRight = !fluteLeftToRight;
    buildFluteChart();
  };
  document.getElementById('fluteOrient').onclick = () => {
    fluteOrientation = fluteOrientation === 'horizontal' ? 'vertical' : 'horizontal';
    buildFluteChart();
  };
}

// ========================= RECORDER CHART =========================
const RECORDER_FINGERINGS = {
  // Accurate baroque recorder fingerings
  // [thumb, L1, L2, L3, R1, R2, R3, R4] - 1=covered, 0=open
  C:[1,1,1,1,1,1,1,1],     // All holes covered
  'C#':[1,1,1,1,1,1,1,0],  // Open lowest hole
  D:[1,1,1,1,1,1,0,0],     // Open bottom two
  'D#':[1,1,1,1,1,0,1,0],  // Cross fingering
  E:[1,1,1,1,1,0,0,0],     // Open bottom three
  F:[1,1,1,1,0,0,0,0],     // Open right hand
  'F#':[1,1,1,0,1,0,0,0],  // Cross fingering
  G:[1,1,1,0,0,0,0,0],     // Left hand only + thumb
  'G#':[1,1,0,1,0,0,0,0],  // Cross fingering
  A:[1,1,0,0,0,0,0,0],     // Thumb + first two left
  'A#':[1,0,1,0,0,0,0,0],  // Cross fingering
  B:[1,0,0,0,0,0,0,0]      // Thumb + index only
};
/*
  Recorder chart layout
  - ViewBox: 0 0 180 60 (overall diagram size)
  - Hole spacing: i*20 (horizontal positioning)
  - Hole radius: r=8
  Adjust these values to change chart size, spacing, or hole size for custom recorders.
*/
function buildRecorderChart(){
  const {rootPc} = computeSelected();
  const note = pcName(rootPc);
  const sharp = ENHARMONIC_MAP[note] || note;
  const fing = RECORDER_FINGERINGS[sharp] || [0,0,0,0,0,0,0,0];
  recorderHost.innerHTML='';
  const svgNS='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(svgNS,'svg');
  const isHoriz = recorderOrientation === 'horizontal';
  svg.setAttribute('viewBox', isHoriz ? '0 0 220 90' : '0 0 90 220');
  svg.setAttribute('class','mx-auto drop-shadow-lg');
  
  // Create recorder body (tapered shape)
  const body = document.createElementNS(svgNS, 'path');
  if(isHoriz) {
    // Horizontal tapered recorder
    const pathData = recorderLeftToRight ? 
      'M 15 35 L 25 25 L 195 30 L 205 40 L 195 50 L 25 55 Z' :
      'M 205 35 L 195 25 L 25 30 L 15 40 L 25 50 L 195 55 Z';
    body.setAttribute('d', pathData);
  } else {
    // Vertical tapered recorder
    const pathData = recorderLeftToRight ?
      'M 35 15 L 25 25 L 30 195 L 40 205 L 50 195 L 55 25 Z' :
      'M 35 205 L 25 195 L 30 25 L 40 15 L 50 25 L 55 195 Z';
    body.setAttribute('d', pathData);
  }
  body.setAttribute('fill', '#8b5a3c');
  body.setAttribute('stroke', '#6d4423');
  body.setAttribute('stroke-width', '2');
  svg.appendChild(body);
  
  // Add finger holes
  fing.forEach((closed,i)=>{
    const c=document.createElementNS(svgNS,'circle');
    let x,y;
    if(isHoriz){
      x = recorderLeftToRight ? 35 + i*20 : 185 - i*20;
      y = 40;
    } else {
      y = recorderLeftToRight ? 35 + i*20 : 185 - i*20;
      x = 40;
    }
    c.setAttribute('cx', String(x));
    c.setAttribute('cy', String(y));
    c.setAttribute('r','7');
    c.setAttribute('stroke', closed ? '#dc2626' : '#6d4423');
    c.setAttribute('stroke-width','3');
    c.setAttribute('fill', closed ? '#dc2626' : '#2c1810');
    svg.appendChild(c);
    
    // Add finger labels (L/R hand indication)
    const label = document.createElementNS(svgNS, 'text');
    const handLabel = i < 4 ? 'L' + (i + 1) : 'R' + (i - 3);
    label.setAttribute('x', String(x));
    label.setAttribute('y', isHoriz ? String(y + 18) : String(x + 18));
    label.setAttribute('text-anchor', 'middle');
    label.setAttribute('font-size', '9');
    label.setAttribute('fill', '#94a3b8');
    label.textContent = handLabel;
    svg.appendChild(label);
  });
  
  // Add mouthpiece
  const mouthpiece = document.createElementNS(svgNS, 'rect');
  if(isHoriz) {
    mouthpiece.setAttribute('x', recorderLeftToRight ? '10' : '200');
    mouthpiece.setAttribute('y', '30');
    mouthpiece.setAttribute('width', '15');
    mouthpiece.setAttribute('height', '20');
  } else {
    mouthpiece.setAttribute('x', '30');
    mouthpiece.setAttribute('y', recorderLeftToRight ? '10' : '200');
    mouthpiece.setAttribute('width', '20');
    mouthpiece.setAttribute('height', '15');
  }
  mouthpiece.setAttribute('fill', '#4a5568');
  mouthpiece.setAttribute('stroke', '#2d3748');
  mouthpiece.setAttribute('stroke-width', '2');
  mouthpiece.setAttribute('rx', '3');
  svg.appendChild(mouthpiece);
  
  recorderHost.appendChild(svg);
  const flip=document.createElement('button');
  flip.id='recorderFlip';
  flip.textContent = isHoriz ? 'Flip ‚Üî' : 'Flip ‚Üï';
  flip.className='mt-2 text-xs px-2 py-1 border border-slate-700 rounded';
  recorderHost.appendChild(flip);
  const orient=document.createElement('button');
  orient.id='recorderOrient';
  orient.textContent = recorderOrientation === 'horizontal' ? 'Vertical' : 'Horizontal';
  orient.className='mt-2 ml-2 text-xs px-2 py-1 border border-slate-700 rounded';
  recorderHost.appendChild(orient);
  const lbl=document.createElement('div');
  lbl.className='mt-2 text-center text-xs text-slate-400';
  lbl.textContent=`Fingering for ${sharp}`;
  recorderHost.appendChild(lbl);
  document.getElementById('recorderFlip').onclick = () => {
    recorderLeftToRight = !recorderLeftToRight;
    buildRecorderChart();
  };
  document.getElementById('recorderOrient').onclick = () => {
    recorderOrientation = recorderOrientation === 'horizontal' ? 'vertical' : 'horizontal';
    buildRecorderChart();
  };
}

// ========================= TRUMPET CHART =========================
const TRUMPET_FINGERINGS = {
  C:[0,0,0],
  'C#':[1,1,1],
  D:[1,0,1],
  'D#':[0,1,1],
  E:[1,1,0],
  F:[1,0,0],
  'F#':[0,1,0],
  G:[0,0,0],
  'G#':[0,1,1],
  A:[1,1,0],
  'A#':[1,0,0],
  B:[0,1,0]
};
/*
  Trumpet chart layout
  - ViewBox: 0 0 120 60 (overall diagram size)
  - Valve spacing: i*40 (positioning)
  - Valve radius: r=12
  Adjust these numbers to resize the chart or reposition valves.
*/
function buildTrumpetChart(){
  const {rootPc} = computeSelected();
  const note = pcName(rootPc);
  const sharp = ENHARMONIC_MAP[note] || note;
  const fing = TRUMPET_FINGERINGS[sharp] || [0,0,0];
  trumpetHost.innerHTML='';
  const svgNS='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(svgNS,'svg');
  const isHoriz = trumpetOrientation === 'horizontal';
  svg.setAttribute('viewBox', isHoriz ? '0 0 120 60' : '0 0 60 120');
  svg.setAttribute('class','mx-auto');
  fing.forEach((down,i)=>{
    const c=document.createElementNS(svgNS,'circle');
    let x,y;
    if(isHoriz){
      x = trumpetLeftToRight ? 20 + i*40 : 100 - i*40;
      y = 30;
    } else {
      y = trumpetLeftToRight ? 20 + i*40 : 100 - i*40;
      x = 30;
    }
    c.setAttribute('cx',String(x));
    c.setAttribute('cy',String(y));
    c.setAttribute('r','12');
    c.setAttribute('stroke','#fbbf24');
    c.setAttribute('stroke-width','2');
    c.setAttribute('fill', down ? '#fbbf24' : 'transparent');
    svg.appendChild(c);
  });
  trumpetHost.appendChild(svg);
  const flip=document.createElement('button');
  flip.id='trumpetFlip';
  flip.textContent = isHoriz ? 'Flip ‚Üî' : 'Flip ‚Üï';
  flip.className='mt-2 text-xs px-2 py-1 border border-slate-700 rounded';
  trumpetHost.appendChild(flip);
  const orient=document.createElement('button');
  orient.id='trumpetOrient';
  orient.textContent = trumpetOrientation === 'horizontal' ? 'Vertical' : 'Horizontal';
  orient.className='mt-2 ml-2 text-xs px-2 py-1 border border-slate-700 rounded';
  trumpetHost.appendChild(orient);
  const lbl=document.createElement('div');
  lbl.className='mt-2 text-center text-xs text-slate-400';
  lbl.textContent=`Valve combo for ${sharp}`;
  trumpetHost.appendChild(lbl);
  document.getElementById('trumpetFlip').onclick = () => {
    trumpetLeftToRight = !trumpetLeftToRight;
    buildTrumpetChart();
  };
  document.getElementById('trumpetOrient').onclick = () => {
    trumpetOrientation = trumpetOrientation === 'horizontal' ? 'vertical' : 'horizontal';
    buildTrumpetChart();
  };
}

// ========================= SAXOPHONE CHART =========================
const SAX_FINGERINGS = {
  C:[1,1,1,1,1,1],
  'C#':[0,1,1,1,1,1],
  D:[0,1,1,1,1,1],
  'D#':[0,0,1,1,1,1],
  E:[0,0,1,1,1,1],
  F:[0,0,0,1,1,1],
  'F#':[0,0,0,0,1,1],
  G:[0,0,0,0,1,1],
  'G#':[0,0,0,0,0,1],
  A:[0,0,0,0,0,1],
  'A#':[0,0,0,0,0,0],
  B:[0,0,0,0,0,0]
};
/*
  Saxophone chart layout
  - ViewBox: 0 0 160 60 (overall diagram size)
  - Key spacing: i*22 (positioning)
  - Key radius: r=10
  Adjust these values to resize the chart or reposition keys.
*/
function buildSaxophoneChart(){
  const {rootPc} = computeSelected();
  const note = pcName(rootPc);
  const sharp = ENHARMONIC_MAP[note] || note;
  const fing = SAX_FINGERINGS[sharp] || [0,0,0,0,0,0];
  saxophoneHost.innerHTML='';
  const svgNS='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(svgNS,'svg');
  const isHoriz = saxophoneOrientation === 'horizontal';
  svg.setAttribute('viewBox', isHoriz ? '0 0 160 60' : '0 0 60 160');
  svg.setAttribute('class','mx-auto');
  fing.forEach((closed,i)=>{
    const c=document.createElementNS(svgNS,'circle');
    let x,y;
    if(isHoriz){
      x = saxophoneLeftToRight ? 20 + i*22 : 140 - i*22;
      y = 30;
    } else {
      y = saxophoneLeftToRight ? 20 + i*22 : 140 - i*22;
      x = 30;
    }
    c.setAttribute('cx', String(x));
    c.setAttribute('cy', String(y));
    c.setAttribute('r','10');
    c.setAttribute('stroke','#fbbf24');
    c.setAttribute('stroke-width','2');
    c.setAttribute('fill', closed ? '#fbbf24' : 'transparent');
    svg.appendChild(c);
  });
  saxophoneHost.appendChild(svg);
  const flip=document.createElement('button');
  flip.id='saxophoneFlip';
  flip.textContent = isHoriz ? 'Flip ‚Üî' : 'Flip ‚Üï';
  flip.className='mt-2 text-xs px-2 py-1 border border-slate-700 rounded';
  saxophoneHost.appendChild(flip);
  const orient=document.createElement('button');
  orient.id='saxophoneOrient';
  orient.textContent = saxophoneOrientation === 'horizontal' ? 'Vertical' : 'Horizontal';
  orient.className='mt-2 ml-2 text-xs px-2 py-1 border border-slate-700 rounded';
  saxophoneHost.appendChild(orient);
  const lbl=document.createElement('div');
  lbl.className='mt-2 text-center text-xs text-slate-400';
  lbl.textContent=`Fingering for ${sharp}`;
  saxophoneHost.appendChild(lbl);
  document.getElementById('saxophoneFlip').onclick = () => {
    saxophoneLeftToRight = !saxophoneLeftToRight;
    buildSaxophoneChart();
  };
  document.getElementById('saxophoneOrient').onclick = () => {
    saxophoneOrientation = saxophoneOrientation === 'horizontal' ? 'vertical' : 'horizontal';
    buildSaxophoneChart();
  };
}

// ========================= NEY CHART =========================
const NEY_FINGERINGS = {
  // Traditional Turkish/Arabic Ney fingerings
  // [thumb(back), index, middle, ring, pinky, R_index, R_middle] - 1=covered, 0=open
  C:[1,1,1,1,1,1,1],     // All holes covered (lowest note)
  'C#':[1,1,1,1,1,1,0],  // Open last hole
  D:[1,1,1,1,1,0,0],     // Open bottom two
  'D#':[1,1,1,1,0,1,0],  // Half-hole technique
  E:[1,1,1,1,0,0,0],     // Open right hand
  F:[1,1,1,0,0,0,0],     // Open ring + right hand
  'F#':[1,1,0,1,0,0,0],  // Cross fingering
  G:[1,1,0,0,0,0,0],     // Basic G
  'G#':[1,0,1,0,0,0,0],  // Cross fingering
  A:[1,0,0,0,0,0,0],     // Thumb + index
  'A#':[0,1,0,0,0,0,0],  // Index only (+ breath control)
  B:[0,0,0,0,0,0,0]      // All open (+ strong breath)
};
/*
  Ney chart layout
  - ViewBox: 0 0 60 160 (overall diagram size)
  - Hole spacing: 20 + i*22 (vertical positioning; first hole x=20, others x=30)
  - Hole radius: r=8
  Tweak these parameters to alter chart size, hole spacing, or radius for custom ney designs.
*/
function buildNeyChart(){
  const {rootPc} = computeSelected();
  const note = pcName(rootPc);
  const sharp = ENHARMONIC_MAP[note] || note;
  const fing = NEY_FINGERINGS[sharp] || [0,0,0,0,0,0,0];
  neyHost.innerHTML='';
  const svgNS='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(svgNS,'svg');
  const isHoriz = neyOrientation === 'horizontal';
  svg.setAttribute('viewBox', isHoriz ? '0 0 200 80' : '0 0 80 200');
  svg.setAttribute('class','mx-auto drop-shadow-lg');
  
  // Create ney body (elegant bamboo-like cylinder)
  const body = document.createElementNS(svgNS, 'rect');
  if(isHoriz) {
    body.setAttribute('x', '15');
    body.setAttribute('y', '30');
    body.setAttribute('width', '170');
    body.setAttribute('height', '20');
  } else {
    body.setAttribute('x', '30');
    body.setAttribute('y', '15');
    body.setAttribute('width', '20');
    body.setAttribute('height', '170');
  }
  body.setAttribute('fill', '#a16207');
  body.setAttribute('stroke', '#854d0e');
  body.setAttribute('stroke-width', '2');
  body.setAttribute('rx', '10');
  svg.appendChild(body);
  
  // Add bamboo segments (decorative lines)
  for(let i = 1; i < 6; i++) {
    const segment = document.createElementNS(svgNS, 'line');
    if(isHoriz) {
      const x = 15 + (170 * i / 6);
      segment.setAttribute('x1', String(x));
      segment.setAttribute('y1', '30');
      segment.setAttribute('x2', String(x));
      segment.setAttribute('y2', '50');
    } else {
      const y = 15 + (170 * i / 6);
      segment.setAttribute('x1', '30');
      segment.setAttribute('y1', String(y));
      segment.setAttribute('x2', '50');
      segment.setAttribute('y2', String(y));
    }
    segment.setAttribute('stroke', '#713f12');
    segment.setAttribute('stroke-width', '1');
    svg.appendChild(segment);
  }
  
  // Add finger holes
  fing.forEach((closed,i)=>{
    const c=document.createElementNS(svgNS,'circle');
    let x,y;
    if(isHoriz){
      x = neyLeftToRight ? 35 + i*22 : 165 - i*22;
      y = 40;
    } else {
      // Special positioning for ney: thumb hole on back (offset)
      x = i===0 ? 25 : 40; // Thumb hole slightly offset
      y = neyLeftToRight ? 35 + i*22 : 165 - i*22;
    }
    c.setAttribute('cx', String(x));
    c.setAttribute('cy', String(y));
    c.setAttribute('r','6');
    c.setAttribute('stroke', closed ? '#dc2626' : '#713f12');
    c.setAttribute('stroke-width','3');
    c.setAttribute('fill', closed ? '#dc2626' : '#451a03');
    svg.appendChild(c);
    
    // Add finger labels with traditional names
    const label = document.createElementNS(svgNS, 'text');
    const fingerNames = ['T', '1', '2', '3', '4', '5', '6']; // T = Thumb
    label.setAttribute('x', String(x));
    label.setAttribute('y', isHoriz ? String(y + 18) : String(x + 18));
    label.setAttribute('text-anchor', 'middle');
    label.setAttribute('font-size', '9');
    label.setAttribute('fill', '#94a3b8');
    label.textContent = fingerNames[i] || String(i);
    svg.appendChild(label);
  });
  
  // Add mouthpiece (beveled edge)
  const mouthpiece = document.createElementNS(svgNS, 'ellipse');
  if(isHoriz) {
    mouthpiece.setAttribute('cx', neyLeftToRight ? '10' : '190');
    mouthpiece.setAttribute('cy', '40');
    mouthpiece.setAttribute('rx', '8');
    mouthpiece.setAttribute('ry', '12');
  } else {
    mouthpiece.setAttribute('cx', '40');
    mouthpiece.setAttribute('cy', neyLeftToRight ? '10' : '190');
    mouthpiece.setAttribute('rx', '12');
    mouthpiece.setAttribute('ry', '8');
  }
  mouthpiece.setAttribute('fill', '#a16207');
  mouthpiece.setAttribute('stroke', '#713f12');
  mouthpiece.setAttribute('stroke-width', '3');
  svg.appendChild(mouthpiece);
  
  neyHost.appendChild(svg);
  const flip=document.createElement('button');
  flip.id='neyFlip';
  flip.textContent = isHoriz ? 'Flip ‚Üî' : 'Flip ‚Üï';
  flip.className='mt-2 text-xs px-2 py-1 border border-slate-700 rounded';
  neyHost.appendChild(flip);
  const orient=document.createElement('button');
  orient.id='neyOrient';
  orient.textContent = neyOrientation === 'horizontal' ? 'Vertical' : 'Horizontal';
  orient.className='mt-2 ml-2 text-xs px-2 py-1 border border-slate-700 rounded';
  neyHost.appendChild(orient);
  const lbl=document.createElement('div');
  lbl.className='mt-2 text-center text-xs text-slate-400';
  lbl.textContent=`Fingering for ${sharp}`;
  neyHost.appendChild(lbl);
  document.getElementById('neyFlip').onclick = () => {
    neyLeftToRight = !neyLeftToRight;
    buildNeyChart();
  };
  document.getElementById('neyOrient').onclick = () => {
    neyOrientation = neyOrientation === 'horizontal' ? 'vertical' : 'horizontal';
    buildNeyChart();
  };
}

// ========================= EXPORT HELPERS =========================
function buildNoteEvents(){ const cur=computeSelected(); if(cur.type==='chord'){ const list=chordToMidi(cur.notes, keyRoot, instrument.startsWith('Bass')?2:4); const start=0,dur=1; return list.map(m=>({start,dur,midi:m,vel:100})); } const seq=scaleToMidi(cur.notes, keyRoot, instrument.startsWith('Bass')?2:4); return seq.map((m,i)=>({start:i*0.5, dur:0.45, midi:m, vel:100})); }
function copyCSV(){ const ev=buildNoteEvents(); const toName=m=> pcName(mod(m,OCTAVE))+(Math.floor(m/OCTAVE)-1); const lines=['note,start(dur beats),dur,vel', ...ev.map(e=> `${toName(e.midi)},${e.start.toFixed(3)},${e.dur.toFixed(3)},${e.vel}`)]; return navigator.clipboard.writeText(lines.join('\n')); }
function downloadMID(){ const bytes=buildMidi(buildNoteEvents(),96,130); const blob=new Blob([bytes],{type:'audio/midi'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`${keyRoot}-${mode==='chord'?chordQuality:scaleMode}.mid`; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),1500); }

// ========================= TESTS =========================
function addTest(list, name, pass, details){ list.push({name,pass,details}); }
function runTests(){
  const t=[];
  addTest(t,'pcIndex C = 0', pcIndex('C')===0);
  addTest(t,'pcIndex C# = 1', pcIndex('C#')===1);
  addTest(t,'pcIndex C+ = 0.5', pcIndex('C+')===0.5);
  addTest(t,'pcName 0.5 = C+', pcName(0.5)==='C+');
  addTest(t,'toSharp(Db)=C#', toSharpName('Db')==='C#');
  addTest(t,'toSharp(E#)=F', toSharpName('E#')==='F');
  addTest(t,'toSharp(B#)=C', toSharpName('B#')==='C');
  addTest(t,'toSharp(Cb)=B', toSharpName('Cb')==='B');
  addTest(t,'C Ionian ok', JSON.stringify(buildScale('C','Ionian'))===JSON.stringify(['C','D','E','F','G','A','B']));
  addTest(t,'A Dorian ok', JSON.stringify(buildScale('A','Dorian'))===JSON.stringify(['A','B','C','D','E','F#','G']));
  addTest(t,'E Blues has A#', buildScale('E','Blues').includes('A#'));
  addTest(t,'G Mixolydian len=7', buildScale('G','Mixolydian').length===7);
  addTest(t,'A Major Pentatonic len=5', buildScale('A','Major Pentatonic').length===5);
  addTest(t,'C Maqam Rast has D#+', buildScale('C','Maqam Rast').includes('D#+'));
  addTest(t,'D Maqam Bayati has D#+', buildScale('D','Maqam Bayati')[1]==='D#+');
  addTest(t,'C Maj chord', JSON.stringify(buildChord('C','Maj'))===JSON.stringify(['C','E','G']));
  addTest(t,'G7 chord', JSON.stringify(buildChord('G','7'))===JSON.stringify(['G','B','D','F']));
  addTest(t,'Bm7b5 chord', JSON.stringify(buildChord('B','m7b5'))===JSON.stringify(['B','D','F','A']));
  addTest(t,'Dsus4 chord', JSON.stringify(buildChord('D','Sus4'))===JSON.stringify(['D','G','A']));
  const cm=chordToMidi(['C','E','G'],'C',4);
  addTest(t,'ChordToMidi >=3', cm.length>=3, cm.join(','));
  const sc=scaleToMidi(['C','D','E','F','G','A','B'],'C',4);
  addTest(t,'ScaleToMidi >=14', sc.length>=14, String(sc.length));
  const maq=scaleToMidi(buildScale('C','Maqam Rast'),'C',4);
  addTest(t,'ScaleToMidi quarter-tone', maq.includes(63.5));
  const fq=midiToFreq(60.5);
  addTest(t,'midiToFreq 60.5', Math.abs(fq - 440*Math.pow(2,(60.5-69)/12))<0.01, fq.toFixed(2));
  addTest(t,'MODE_SYSTEMS maqam', MODE_SYSTEMS.Maqam.includes('Maqam Rast'));
  const testsEl=document.getElementById('tests'); testsEl.innerHTML='';
  t.forEach((r)=>{ const li=document.createElement('div'); li.className='px-3 py-2 rounded-lg border '+ (r.pass?'border-emerald-700 bg-emerald-900/30 text-emerald-200':'border-rose-700 bg-rose-900/30 text-rose-200'); li.innerHTML = '<span class="font-semibold">'+(r.pass?'PASS':'FAIL')+'</span> ‚Äî '+r.name + (r.details? ('<div class="text-xs opacity-75">'+r.details+'</div>'):''); testsEl.appendChild(li); });
}

// ========================= WIRING =========================
function refreshInstruments(){
  const isGuitar = selInstr.value.startsWith('Guitar') || selInstr.value.startsWith('Oud');
  const isBass = selInstr.value.startsWith('Bass');
  const isViolin = selInstr.value.startsWith('Violin');
  const isFlute = selInstr.value.startsWith('Flute');
  const isRecorder = selInstr.value.startsWith('Recorder');
  const isTrumpet = selInstr.value.startsWith('Trumpet');
  const isSaxophone = selInstr.value.startsWith('Saxophone');
  const isKoto = selInstr.value.startsWith('Koto');
  const isNey = selInstr.value.startsWith('Ney');
  guitarHost.classList.toggle('hidden', !isGuitar);
  bassHost.classList.toggle('hidden', !isBass);
  violinHost.classList.toggle('hidden', !isViolin);
  fluteHost.classList.toggle('hidden', !isFlute);
  recorderHost.classList.toggle('hidden', !isRecorder);
  trumpetHost.classList.toggle('hidden', !isTrumpet);
  saxophoneHost.classList.toggle('hidden', !isSaxophone);
  kotoHost.classList.toggle('hidden', !isKoto);
  neyHost.classList.toggle('hidden', !isNey);
  if(!violinHost.classList.contains('hidden')) buildFretboard(violinHost, VIOLIN_TUNING,'Violin (12 positions)');
  if(!fluteHost.classList.contains('hidden')) buildFluteChart();
  if(!recorderHost.classList.contains('hidden')) buildRecorderChart();
  if(!trumpetHost.classList.contains('hidden')) buildTrumpetChart();
  if(!saxophoneHost.classList.contains('hidden')) buildSaxophoneChart();
  if(!kotoHost.classList.contains('hidden')) buildKotoBoard();
  if(!neyHost.classList.contains('hidden')) buildNeyChart();
  btnPlayStrum.classList.toggle('hidden', !isGuitar);
}
function updateAll(){
  renderHighlights();
  updateBadges();
  if(!guitarHost.classList.contains('hidden'))
    buildFretboard(guitarHost, GUITAR_STD,'Guitar (12 frets)');
  if(!bassHost.classList.contains('hidden'))
    buildFretboard(bassHost, BASS_STD,'Bass (12 frets)');
  if(!violinHost.classList.contains('hidden'))
    buildFretboard(violinHost, VIOLIN_TUNING,'Violin (12 positions)');
  if(!fluteHost.classList.contains('hidden'))
    buildFluteChart();
  if(!recorderHost.classList.contains('hidden'))
    buildRecorderChart();
  if(!trumpetHost.classList.contains('hidden'))
    buildTrumpetChart();
  if(!saxophoneHost.classList.contains('hidden'))
    buildSaxophoneChart();
  if(!kotoHost.classList.contains('hidden'))
    buildKotoBoard();
  if(!neyHost.classList.contains('hidden'))
    buildNeyChart();
}

// Build UI
buildPiano(); refreshInstruments(); updateAll(); runTests(); initSequencer();
// === TAB: Sequencer wiring (non-destructive) ===
btnModeChord.addEventListener('click', ()=>{
  mode='Chord';
  btnModeChord.className='px-3 py-2 text-sm bg-slate-700/70';
  btnModeScale.className='px-3 py-2 text-sm bg-slate-800/60 hover:bg-slate-700/50';
  btnModeSequencer.className='px-3 py-2 text-sm bg-slate-800/60 hover:bg-slate-700/50';
  wrapChord.classList.remove('hidden');
  wrapScale.classList.add('hidden');
  listenChord.classList.remove('hidden');
  listenScale.classList.add('hidden');
  sequencerHost.classList.add('hidden');
  updateAll();
});
btnModeScale.addEventListener('click', ()=>{
  mode='Scale/Mode';
  btnModeScale.className='px-3 py-2 text-sm bg-slate-700/70';
  btnModeChord.className='px-3 py-2 text-sm bg-slate-800/60 hover:bg-slate-700/50';
  btnModeSequencer.className='px-3 py-2 text-sm bg-slate-800/60 hover:bg-slate-700/50';
  wrapScale.classList.remove('hidden');
  wrapChord.classList.add('hidden');
  listenScale.classList.remove('hidden');
  listenChord.classList.add('hidden');
  sequencerHost.classList.add('hidden');
  updateAll();
});
btnModeSequencer.addEventListener('click', ()=>{
  mode='Sequencer';
  btnModeSequencer.className='px-3 py-2 text-sm bg-slate-700/70';
  btnModeChord.className='px-3 py-2 text-sm bg-slate-800/60 hover:bg-slate-700/50';
  btnModeScale.className='px-3 py-2 text-sm bg-slate-800/60 hover:bg-slate-700/50';
  wrapChord.classList.add('hidden');
  wrapScale.classList.add('hidden');
  listenChord.classList.add('hidden');
  listenScale.classList.add('hidden');
  sequencerHost.classList.remove('hidden');
  updateAll();
});

selKey.addEventListener('change', (e)=>{ keyRoot = e.target.value; updateAll(); });
selQuality.addEventListener('change', (e)=>{ chordQuality = e.target.value; updateAll(); });
selMode.addEventListener('change', (e)=>{ scaleMode = e.target.value; updateAll(); });
selInstr.addEventListener('change', (e)=>{ instrument = e.target.value; refreshInstruments(); updateAll(); });
selSystem.addEventListener('change', (e)=>{ system = e.target.value; populateModeOptions(); updateAll(); });
tempoInput.addEventListener('input', e => setBpm(Number(e.target.value) || song.bpm));
seqBpm.addEventListener('input', e => setBpm(Number(e.target.value) || song.bpm));
seqLoop.addEventListener('change', ()=>{ song.loop.enabled = seqLoop.checked; updateLoop(); });
seqTSNum.addEventListener('change', ()=>{ song.ts.num = Math.max(1,Math.min(16,Number(seqTSNum.value)||4)); drawPianoRoll(); });
seqTSDen.addEventListener('change', ()=>{ const allowed=[1,2,4,8,16]; const v=Number(seqTSDen.value); song.ts.den = allowed.includes(v)?v:4; drawPianoRoll(); });

// Quantization controls
seqQuantize.addEventListener('change', ()=>{
  const value = Number(seqQuantize.value);
  quantizeSnap = value || SIXTEENTH; // Default to 1/16 if "Off" is selected for snap-to-grid
});

seqQuantizeBtn.addEventListener('click', ()=>{
  if(selectedNotes.size === 0) {
    // If no notes selected, select all notes on active track
    selectAll();
  }
  quantizeSelected();
});

// Transport controls
seqToStart.addEventListener('click', jumpToStart);
seqToEnd.addEventListener('click', jumpToEnd);

// Click-to-position functionality
seqPosition.addEventListener('click', () => {
  const input = prompt('Jump to position (bars:beats:ticks or just bars):', ticksToBarsBeatsTicks(Tone.Transport.ticks));
  if(!input) return;
  
  try {
    const parts = input.split(':').map(p => parseInt(p.trim()));
    let ticks = 0;
    
    if(parts.length === 1) {
      // Just bars specified
      ticks = (parts[0] - 1) * song.ts.num * song.ppq;
    } else if(parts.length === 2) {
      // Bars and beats
      ticks = (parts[0] - 1) * song.ts.num * song.ppq + (parts[1] - 1) * song.ppq;
    } else if(parts.length === 3) {
      // Full bars:beats:ticks
      ticks = (parts[0] - 1) * song.ts.num * song.ppq + (parts[1] - 1) * song.ppq + parts[2];
    }
    
    Tone.Transport.ticks = Math.max(0, ticks);
    updatePositionDisplay();
    drawPianoRoll();
  } catch(e) {
    alert('Invalid position format. Use bars:beats:ticks (e.g., 2:1:0)');
  }
});

// Update position display every 100ms when playing
setInterval(() => {
  if(sequencerState === 'playing') {
    updatePositionDisplay();
  }
}, 100);

// Note length preset buttons
noteLengthBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    // Update visual state
    noteLengthBtns.forEach(b => b.classList.remove('bg-blue-600'));
    btn.classList.add('bg-blue-600');
    
    // Update selected length
    selectedNoteLength = parseInt(btn.dataset.length);
    lastNoteDur = selectedNoteLength;
    
    // Apply to selected notes if any
    if(selectedNotes.size > 0) {
      saveState('Change note length');
      selectedNotes.forEach(note => {
        note.dur = selectedNoteLength;
      });
      drawPianoRoll();
      if(Tone.Transport.state==='started') scheduleSong(activeTrack);
    }
  });
});

// Pattern library event handlers
document.querySelectorAll('.pattern-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const patternName = btn.dataset.pattern;
    const pattern = PATTERN_LIBRARY[patternName];
    if(!pattern) return;
    
    saveState(`Load pattern: ${patternName}`);
    
    const track = song.tracks[activeTrack];
    const startTick = Tone.Transport.ticks || 0;
    
    // Clear selection and add pattern notes
    selectedNotes.clear();
    pattern.forEach(noteTemplate => {
      const newNote = {
        ...noteTemplate,
        tick: startTick + noteTemplate.tick
      };
      track.clips[0].notes.push(newNote);
      selectedNotes.add(newNote);
    });
    
    track.clips[0].notes.sort((a,b) => a.tick - b.tick);
    drawPianoRoll();
    if(Tone.Transport.state==='started') scheduleSong(activeTrack);
    
    scheduleAutoSave();
  });
});

document.getElementById('savePatternBtn').addEventListener('click', () => {
  if(selectedNotes.size === 0) {
    alert('Please select notes to save as a pattern');
    return;
  }
  
  const patternName = prompt('Enter pattern name:');
  if(!patternName) return;
  
  // Create pattern from selected notes
  const selectedArray = Array.from(selectedNotes);
  const minTick = Math.min(...selectedArray.map(n => n.tick));
  
  const pattern = selectedArray.map(note => ({
    tick: note.tick - minTick,
    dur: note.dur,
    midi: note.midi,
    vel: note.vel || 0.8
  }));
  
  PATTERN_LIBRARY[patternName] = pattern;
  
  // Save to localStorage
  try {
    localStorage.setItem('customPatterns', JSON.stringify(PATTERN_LIBRARY));
    alert(`Pattern "${patternName}" saved!`);
  } catch(e) {
    alert('Failed to save pattern');
  }
});

document.getElementById('exportSelectedBtn').addEventListener('click', exportSelectedNotes);

// Auto-save functionality
function scheduleAutoSave() {
  if(autoSaveTimer) clearTimeout(autoSaveTimer);
  
  autoSaveTimer = setTimeout(() => {
    try {
      const songData = serializeSong();
      localStorage.setItem('autoSave', songData);
      const timestamp = new Date().toLocaleTimeString();
      seqStatus.textContent = `‚úì Auto-saved at ${timestamp}`;
    } catch(e) {
      console.warn('Auto-save failed:', e);
    }
  }, AUTO_SAVE_DELAY);
}

function exportSelectedNotes() {
  if(selectedNotes.size === 0) {
    alert('Please select notes to export');
    return;
  }
  
  const selectedArray = Array.from(selectedNotes);
  const minTick = Math.min(...selectedArray.map(n => n.tick));
  
  const exportData = {
    notes: selectedArray.map(note => ({
      tick: note.tick - minTick,
      dur: note.dur,
      midi: note.midi,
      vel: note.vel || 0.8
    })),
    metadata: {
      track: song.tracks[activeTrack].name,
      instrument: song.tracks[activeTrack].instrument,
      noteCount: selectedArray.length,
      exportTime: new Date().toISOString()
    }
  };
  
  const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `notes_${song.tracks[activeTrack].name}_${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
  
  seqStatus.textContent = `‚úì Exported ${selectedArray.length} notes`;
}

// Theme system
const themeSwitcher = document.getElementById('themeSwitcher');
const appContainer = document.getElementById('app-container');

themeSwitcher.addEventListener('change', (e) => {
  const theme = e.target.value;
  appContainer.setAttribute('data-theme', theme);
  
  // Save preference
  try {
    localStorage.setItem('selectedTheme', theme);
  } catch(e) {
    // Ignore localStorage errors
  }
});

// Load saved theme
try {
  const savedTheme = localStorage.getItem('selectedTheme');
  if(savedTheme && themeSwitcher.querySelector(`option[value="${savedTheme}"]`)) {
    themeSwitcher.value = savedTheme;
    appContainer.setAttribute('data-theme', savedTheme);
  }
} catch(e) {
  // Ignore localStorage errors
}

// Shortcuts modal
const shortcutsBtn = document.getElementById('shortcutsBtn');
const shortcutsModal = document.getElementById('shortcutsModal');
const closeShortcuts = document.getElementById('closeShortcuts');

shortcutsBtn.addEventListener('click', () => {
  shortcutsModal.classList.remove('hidden');
});

closeShortcuts.addEventListener('click', () => {
  shortcutsModal.classList.add('hidden');
});

shortcutsModal.addEventListener('click', (e) => {
  if(e.target === shortcutsModal) {
    shortcutsModal.classList.add('hidden');
  }
});

// Close shortcuts modal with Escape
document.addEventListener('keydown', (e) => {
  if(e.key === 'Escape' && !shortcutsModal.classList.contains('hidden')) {
    shortcutsModal.classList.add('hidden');
    e.stopPropagation();
  }
});

// Context menu handling
const noteContextMenu = document.getElementById('noteContextMenu');
let contextMenuNote = null;

function showContextMenu(x, y, note) {
  contextMenuNote = note;
  noteContextMenu.style.left = x + 'px';
  noteContextMenu.style.top = y + 'px';
  noteContextMenu.classList.remove('hidden');
}

function hideContextMenu() {
  noteContextMenu.classList.add('hidden');
  contextMenuNote = null;
}

// Hide context menu on click elsewhere
document.addEventListener('click', (e) => {
  if(!noteContextMenu.contains(e.target)) {
    hideContextMenu();
  }
});

// Velocity editor
function showVelocityEditor() {
  if(selectedNotes.size === 0) return;
  
  const currentVel = Array.from(selectedNotes)[0].vel || 0.8;
  const newVel = parseFloat(prompt(`Enter velocity (0.1 - 1.0):`, currentVel.toFixed(2)));
  
  if(newVel >= 0.1 && newVel <= 1.0) {
    saveState('Change velocity');
    selectedNotes.forEach(note => {
      note.vel = newVel;
    });
    drawPianoRoll();
  }
  
  hideContextMenu();
}

// Advanced selection functions
function selectByPitch() {
  if(selectedNotes.size === 0) return;
  
  const selectedPitches = new Set(Array.from(selectedNotes).map(n => n.midi));
  const track = song.tracks[activeTrack];
  
  selectedNotes.clear();
  track.clips[0].notes.forEach(note => {
    if(selectedPitches.has(note.midi)) {
      selectedNotes.add(note);
    }
  });
  
  drawPianoRoll();
  hideContextMenu();
}

function selectByTiming() {
  if(selectedNotes.size === 0) return;
  
  const selectedTicks = new Set(Array.from(selectedNotes).map(n => {
    // Quantize to nearest beat for timing comparison
    const beatTick = song.ppq;
    return Math.round(n.tick / beatTick) * beatTick;
  }));
  
  const track = song.tracks[activeTrack];
  const beatTick = song.ppq;
  
  selectedNotes.clear();
  track.clips[0].notes.forEach(note => {
    const quantizedTick = Math.round(note.tick / beatTick) * beatTick;
    if(selectedTicks.has(quantizedTick)) {
      selectedNotes.add(note);
    }
  });
  
  drawPianoRoll();
  hideContextMenu();
}

function invertSelection() {
  const track = song.tracks[activeTrack];
  const newSelection = new Set();
  
  track.clips[0].notes.forEach(note => {
    if(!selectedNotes.has(note)) {
      newSelection.add(note);
    }
  });
  
  selectedNotes = newSelection;
  drawPianoRoll();
  hideContextMenu();
}

// Note preview - play note when clicked
function previewNote(midi, velocity = 0.8) {
  if(!_started) return; // Don't preview if audio not started
  
  try {
    const freq = midiToFreq(midi);
    if(_synth) {
      _synth.triggerAttackRelease(freq, '8n', Tone.now(), velocity);
    }
  } catch(e) {
    // Ignore preview errors
  }
}
seqColorScheme.addEventListener('change', e=>applySeqColorScheme(e.target.value));
seqZoomX.addEventListener('input', e=>{ ui.zoomX = Number(e.target.value); drawPianoRoll(); });
seqZoomY.addEventListener('input', e=>{ ui.zoomY = Number(e.target.value); drawPianoRoll(); });
seqClearAll.addEventListener('click', ()=>{ if(confirm('Clear all notes on active track?')){ song.tracks[activeTrack].clips[0].notes=[]; drawPianoRoll(); if(Tone.Transport.state==='started') scheduleSong(activeTrack); }});
seqExportWav.addEventListener('click', handleExportWav);
seqExportMp3.addEventListener('click', handleExportMp3);
$('#btnClearSel').addEventListener('click', clearSelection);

// Listen buttons
$('#btnPlayBlock').addEventListener('click', ()=>{ const sel=computeSelected(); const midi=chordToMidi(sel.notes, keyRoot, instrument.startsWith('Bass')?2:4); playMidiNotes(midi,{instrument, tempo, asChord:true}); });
$('#btnPlayArp').addEventListener('click', ()=>{ const sel=computeSelected(); const midi=chordToMidi(sel.notes, keyRoot, instrument.startsWith('Bass')?2:4); playMidiNotes(midi,{instrument, tempo}); });
$('#btnPlayStrum').addEventListener('click', ()=>{ const sel=computeSelected(); const midi=chordToMidi(sel.notes, keyRoot, instrument.startsWith('Bass')?2:4); playMidiNotes(midi,{instrument, tempo, strum:true}); });
$('#btnPlayScale').addEventListener('click', ()=>{ const sel=computeSelected(); const midi=scaleToMidi(sel.notes, keyRoot, instrument.startsWith('Bass')?2:4); playMidiNotes(midi,{instrument, tempo}); });
$('#btnPlaySelChord').addEventListener('click', ()=>{ const midi=[...selection].sort((a,b)=>a-b); playMidiNotes(midi,{instrument, tempo, asChord:true}); });
$('#btnPlaySelArp').addEventListener('click', ()=>{ const midi=[...selection].sort((a,b)=>a-b); playMidiNotes(midi,{instrument, tempo}); });

seqPlay.addEventListener('click', async ()=>{
  try {
    await ensureTone('Piano');
    
    if(sequencerState === 'paused') {
      // Resume from pause
      Tone.Transport.start();
      startPlayhead();
      sequencerState = 'playing';
      seqPlay.textContent = 'Play';
      return;
    }
    
    // Fresh start
    if(sequencerState === 'playing') {
      return; // Already playing
    }
    
    scheduleSong();
    
    if(seqClick.checked){
      clickId = Tone.Transport.scheduleRepeat(time => {
        const p = ENV.Piano;
        _synth.set({ envelope:{attack:p.a,decay:p.d,sustain:p.s,release:p.r}, oscillator:{type:p.osc} });
        _synth.triggerAttackRelease(midiToFreq(midiFrom('C',5)), '16n', time);
      }, '4n');
    }
    
    // Count-in functionality
    if(seqCountIn.checked && Tone.Transport.ticks === 0) {
      const beatsPerBar = song.ts.num;
      let countBeat = 0;
      
      countInId = Tone.Transport.scheduleRepeat(time => {
        countBeat++;
        // Play count-in sound
        const p = ENV.Piano;
        _synth.set({ envelope:{attack:p.a,decay:p.d,sustain:p.s,release:p.r}, oscillator:{type:p.osc} });
        _synth.triggerAttackRelease(midiToFreq(midiFrom('C',6)), '16n', time, countBeat === 1 ? 1.0 : 0.8);
        
        if(countBeat >= beatsPerBar) {
          Tone.Transport.clear(countInId);
          countInId = null;
        }
      }, '4n', '0:0:0', `1:0:0`);
    }
    
    updateLoop();
    Tone.Transport.start();
    startPlayhead();
    sequencerState = 'playing';
  } catch(error) {
    console.error('Playback error:', error);
    seqStatus.textContent = '‚ùå Playback failed';
  }
});

seqPause.addEventListener('click', ()=>{
  if(sequencerState === 'playing') {
    Tone.Transport.pause();
    stopPlayhead();
    sequencerState = 'paused';
    seqPlay.textContent = 'Resume';
  }
});

seqStop.addEventListener('click', ()=>{
  Tone.Transport.stop();
  Tone.Transport.cancel();
  if(clickId!==null){ Tone.Transport.clear(clickId); clickId=null; }
  if(autoStopId!==null){ Tone.Transport.clear(autoStopId); autoStopId=null; }
  if(countInId!==null){ Tone.Transport.clear(countInId); countInId=null; }
  song.tracks.forEach(t=>{ 
    if(t.part) { t.part.dispose(); t.part = null; }
    if(t.player){ t.player.dispose(); t.player=null; }
  });
  stopPlayhead();
  sequencerState = 'stopped';
  seqPlay.textContent = 'Play';
});

seqExportJson.addEventListener('click', ()=>{
  const blob = new Blob([serializeSong()],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download='song.json';
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url),1500);
  seqStatus.textContent='‚úÖ Exported JSON';
});

seqImportJson.addEventListener('click', ()=> seqImportFile.click());

seqImportFile.addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ev=>{
    try {
      const data = JSON.parse(ev.target.result);
      loadSong(data);
      seqStatus.textContent='‚úÖ Imported JSON';
    } catch(err){
      console.error(err);
      seqStatus.textContent='‚ùå Import failed';
    }
  };
  reader.readAsText(file);
  e.target.value='';
});

seqExportMid.addEventListener('click', ()=>{
  exportSongMidi();
  seqStatus.textContent='‚úÖ Exported MIDI';
});

// Export buttons
$('#btnCopyCSV').addEventListener('click', ()=>{ copyCSV().then(()=>{ $('#copyStatus').textContent='‚úÖ Copied CSV'; }); });
$('#btnMid').addEventListener('click', downloadMID);
$('#btnCopyFL').addEventListener('click', ()=>{ const bytes=buildMidi(buildNoteEvents(),96,130); copyBytesToClipboard(bytes); });

// === SEQUENCER: Import/Export (JSON, MIDI, WAV, MP3) ===
function encodeWavFromFloat32(left, right, sampleRate){
  const frames = Math.max(left.length, right.length);
  const bytesPerSample = 2;
  const numChannels = 2;
  const blockAlign = numChannels * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataBytes = frames * blockAlign;
  const buffer = new ArrayBuffer(44 + dataBytes);
  const view = new DataView(buffer);
  writeStr(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataBytes, true);
  writeStr(view, 8, 'WAVE');
  writeStr(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, 16, true);
  writeStr(view, 36, 'data');
  view.setUint32(40, dataBytes, true);
  let offset = 44;
  for (let i = 0; i < frames; i++){
    const L = Math.max(-1, Math.min(1, left[i]  ?? 0));
    const R = Math.max(-1, Math.min(1, right[i] ?? 0));
    view.setInt16(offset, L < 0 ? L * 0x8000 : L * 0x7FFF, true); offset += 2;
    view.setInt16(offset, R < 0 ? R * 0x8000 : R * 0x7FFF, true); offset += 2;
  }
  return new Blob([buffer], { type: 'audio/wav' });
  function writeStr(v, off, s){ for (let i=0;i<s.length;i++) v.setUint8(off+i, s.charCodeAt(i)); }
}

function createMp3Worker(){
  const LAME_MIN = `/* lamejs minified placeholder */`;
  const workerSrc = `
${'${LAME_MIN}'}
self.onmessage = function(e){ self.postMessage({type:'error', err:'mp3 encode not implemented'}); };
  `;
  return new Worker(URL.createObjectURL(new Blob([workerSrc],{type:'application/javascript'})));
}

function encodeMp3FromFloat32(){ return Promise.reject('mp3 encode not implemented'); }

async function renderSongToBuffer(song){
  const PPQ = song.ppq;
  const qPerBeat = 4 / song.ts.den;
  const ticksPerBeat = PPQ * qPerBeat;
  function songLengthTicks(){ if(song.loop.enabled) return song.loop.end; let maxT=0; for(const t of song.tracks){ for(const cl of t.clips){ for(const n of cl.notes){ const end=cl.start+n.tick+n.dur; if(end>maxT) maxT=end; } } } return maxT + ticksPerBeat*song.ts.num; }
  const totalBeats = songLengthTicks() / ticksPerBeat;
  const seconds = (60 / song.bpm) * totalBeats;
  const buffer = await Tone.Offline(async () => {
    Tone.Transport.cancel();
    Tone.Transport.PPQ = song.ppq;
    Tone.Transport.bpm.value = song.bpm;
    const nodes=[];
    song.tracks.forEach(tr=>{
      const drumFactory = DRUMS[tr.instrument];
      const node = drumFactory?drumFactory():createSeqInstrument(tr.instrument);
      node.setVolume?.(tr.volume ?? 0.8);
      nodes.push(node);
      if(tr.mute) return;
      tr.clips.forEach(cl=>{
        cl.notes.forEach(n=>{
          const startBeats=(cl.start+n.tick)/ticksPerBeat;
          const durBeats=n.dur/ticksPerBeat;
          Tone.Transport.schedule(time=>{ node.trigger(n.midi, time, n.vel||0.8, durBeats); }, startBeats+'i');
        });
      });
    });
    if(song.loop.enabled){ Tone.Transport.loopStart = song.loop.start/ticksPerBeat+'i'; Tone.Transport.loopEnd = song.loop.end/ticksPerBeat+'i'; Tone.Transport.loop = true; }
    Tone.Transport.start();
  }, seconds+0.1);
  return { buffer, sampleRate: buffer.sampleRate };
}

async function handleExportWav(){
  try{
    const {buffer, sampleRate} = await renderSongToBuffer(song);
    const L = buffer.getChannelData(0); const R = buffer.numberOfChannels>1?buffer.getChannelData(1):L;
    const blob = encodeWavFromFloat32(L, R, sampleRate);
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='sequencer.wav'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),1500);
    seqStatus.textContent+=' ‚úÖ WAV exported';
  }catch(err){ seqStatus.textContent+=' ‚ùå WAV export failed'; console.error(err); }
}

async function handleExportMp3(){
  try{
    const {buffer, sampleRate} = await renderSongToBuffer(song);
    const L = buffer.getChannelData(0); const R = buffer.numberOfChannels>1?buffer.getChannelData(1):L;
    const blob = await encodeMp3FromFloat32(new Float32Array(L), new Float32Array(R), sampleRate);
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='sequencer.mp3'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),1500);
    seqStatus.textContent+=' ‚úÖ MP3 exported';
  }catch(err){ seqStatus.textContent+=' ‚ùå MP3 export failed'; console.error(err); }
}
</script>

<!-- Context Menu -->
<div id="noteContextMenu" class="fixed hidden bg-slate-800 border border-slate-600 rounded-lg shadow-xl py-2 z-50 min-w-[180px]">
  <button class="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700" onclick="copySelected()">Copy</button>
  <button class="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700" onclick="cutSelected()">Cut</button>
  <button class="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700" onclick="deleteSelected()">Delete</button>
  <hr class="border-slate-600 my-1">
  <button class="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700" onclick="quantizeSelected()">Quantize</button>
  <button class="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700" onclick="showVelocityEditor()">Edit Velocity...</button>
  <hr class="border-slate-600 my-1">
  <div class="px-4 py-1 text-xs text-slate-400 font-semibold">SELECT</div>
  <button class="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700" onclick="selectByPitch()">Same Pitch</button>
  <button class="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700" onclick="selectByTiming()">Same Timing</button>
  <button class="w-full px-4 py-2 text-left text-sm text-slate-200 hover:bg-slate-700" onclick="invertSelection()">Invert Selection</button>
</div>

<!-- Shortcuts Modal -->
<div id="shortcutsModal" class="fixed inset-0 hidden bg-black/50 shortcuts-modal z-50 flex items-center justify-center">
  <div class="bg-slate-800 rounded-xl shadow-2xl max-w-4xl w-full mx-4 max-h-[80vh] overflow-y-auto">
    <div class="sticky top-0 bg-slate-800 px-6 py-4 border-b border-slate-700 flex items-center justify-between">
      <h2 class="text-xl font-bold text-white">Keyboard Shortcuts & Quick Reference</h2>
      <button id="closeShortcuts" class="text-slate-400 hover:text-white text-2xl font-bold">&times;</button>
    </div>
    <div class="p-6 grid md:grid-cols-2 gap-6">
      <!-- Transport & Playback -->
      <div>
        <h3 class="text-lg font-semibold text-emerald-400 mb-3 border-b border-slate-700 pb-1">Transport & Playback</h3>
        <div class="space-y-2 text-sm">
          <div class="flex justify-between"><span class="text-slate-300">Play/Pause</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Space</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Stop</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Esc</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Jump to Start</span><span class="text-slate-500">|&lt; button</span></div>
          <div class="flex justify-between"><span class="text-slate-300">Jump to End</span><span class="text-slate-500">&gt;| button</span></div>
          <div class="flex justify-between"><span class="text-slate-300">Jump to Position</span><span class="text-slate-500">Click position display</span></div>
        </div>
      </div>
      
      <!-- Selection -->
      <div>
        <h3 class="text-lg font-semibold text-blue-400 mb-3 border-b border-slate-700 pb-1">Note Selection</h3>
        <div class="space-y-2 text-sm">
          <div class="flex justify-between"><span class="text-slate-300">Select Note</span><span class="text-slate-500">Click note</span></div>
          <div class="flex justify-between"><span class="text-slate-300">Toggle Selection</span><span class="text-slate-500">Shift+Click</span></div>
          <div class="flex justify-between"><span class="text-slate-300">Add to Selection</span><span class="text-slate-500">Ctrl+Click</span></div>
          <div class="flex justify-between"><span class="text-slate-300">Select All</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+A</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Select by Pitch</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+P</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Select by Timing</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+T</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Invert Selection</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+I</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Multi-Select Area</span><span class="text-slate-500">Shift+Drag</span></div>
        </div>
      </div>
      
      <!-- Editing -->
      <div>
        <h3 class="text-lg font-semibold text-purple-400 mb-3 border-b border-slate-700 pb-1">Editing</h3>
        <div class="space-y-2 text-sm">
          <div class="flex justify-between"><span class="text-slate-300">Copy</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+C</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Cut</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+X</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Paste</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+V</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Delete</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Delete</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Undo</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+Z</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Redo</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+Y</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Quantize</span><kbd class="bg-slate-700 px-2 py-1 rounded text-xs">Ctrl+Q</kbd></div>
          <div class="flex justify-between"><span class="text-slate-300">Edit Velocity</span><span class="text-slate-500">Right-click menu</span></div>
        </div>
      </div>
      
      <!-- View & Navigation -->
      <div>
        <h3 class="text-lg font-semibold text-yellow-400 mb-3 border-b border-slate-700 pb-1">View & Navigation</h3>
        <div class="space-y-2 text-sm">
          <div class="flex justify-between"><span class="text-slate-300">Zoom X</span><span class="text-slate-500">Ctrl+Wheel</span></div>
          <div class="flex justify-between"><span class="text-slate-300">Zoom Y</span><span class="text-slate-500">Alt+Wheel</span></div>
          <div class="flex justify-between"><span class="text-slate-300">Scroll Horizontal</span><span class="text-slate-500">Shift+Wheel</span></div>
          <div class="flex justify-between"><span class="text-slate-300">Auto-scroll</span><span class="text-slate-500">Toggle checkbox</span></div>
        </div>
      </div>
      
      <!-- Tips & Tricks -->
      <div class="md:col-span-2">
        <h3 class="text-lg font-semibold text-pink-400 mb-3 border-b border-slate-700 pb-1">Tips & Tricks</h3>
        <div class="grid md:grid-cols-2 gap-4 text-sm">
          <div>
            <h4 class="font-medium text-slate-300 mb-2">Track Management</h4>
            <ul class="space-y-1 text-slate-400">
              <li>‚Ä¢ Double-click track names to edit</li>
              <li>‚Ä¢ Use M/S buttons for mute/solo</li>
              <li>‚Ä¢ Drag volume sliders for levels</li>
              <li>‚Ä¢ Right-click notes for context menu</li>
            </ul>
          </div>
          <div>
            <h4 class="font-medium text-slate-300 mb-2">Pattern Library</h4>
            <ul class="space-y-1 text-slate-400">
              <li>‚Ä¢ Use built-in drum/chord patterns</li>
              <li>‚Ä¢ Save custom patterns from selection</li>
              <li>‚Ä¢ Export selected notes as JSON</li>
              <li>‚Ä¢ Auto-save protects your work</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
